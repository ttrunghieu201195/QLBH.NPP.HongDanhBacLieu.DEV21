<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ZipForge</name>
    </assembly>
    <members>
        <member name="T:ComponentAce.Compression.Archiver.Encryption.CryptoTransformMode">
            <summary>
            The enumeration used to define crypto transform mode (encryption||decryption)
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Encryption.PBKDF2">
            <summary>
            Password Based Key Derivation Function 2
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PBKDF2.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor takes three parameters: password, the size of the salt value and the number of iterations
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PBKDF2.#ctor(System.String,System.Byte[],System.Int32)">
            <summary>
            Constructor takes three parameters: password, the salt value and the number of iterations
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PBKDF2.Int(System.UInt32)">
            <summary>
            Converts the uint value to an array of bytes
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PBKDF2.GetKeyBytes(System.Int32)">
            <summary>
            Generate a key based on the password
            </summary>
            <param name="cb">The length of the key to be generated</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PBKDF2.Reset">
            <summary>
            Resets the generator
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Encryption.PBKDF2.IterationCount">
            <summary>
            The number of iterations to perform in order to derive a key
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Encryption.PBKDF2.Salt">
            <summary>
            The salt value
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Encryption.BaseZipForgeCryptoTransform">
            <summary>
            Abstract base class which should be overiding by classes implementing crypting algorithms in zip archives
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Encryption.BaseZipForgeCryptoTransform.TransformMode">
            <summary>
            Gets the value of the crypto transform mode
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Encryption.PkzipClassicCryptoTransform">
            <summary>
            Class implementing PkzipClassic cryptographic algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PkzipClassicCryptoTransform.GenerateKey(System.String)">
            <summary>
            Derives key from the password and generates KeyHeader
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Encryption.PkzipClassicCryptoTransform.ZipEncryptByte(System.Byte)">
            <summary>
            Encrypts one byte
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Encryption.AESCryptoTransform">
            <summary>
            AES encryption
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver">
            <summary>
            Abstract base class for <see cref="T:ComponentAce.Compression.ZipForge.ZipForge"/> and FlexCompress.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ZIPDecompress(System.Boolean,System.Int32@,System.Int32,System.Int64@,System.IO.Stream@,System.IO.Stream,System.UInt32@,ComponentAce.Compression.Archiver.Encryption.BaseZipForgeCryptoTransform,ComponentAce.Compression.Archiver.DirItem)">
            <summary>
            Decompresses a file within ZIP archive
            </summary>
            <param name="encrypted">Specifies whether the file is encrypted</param>
            <param name="volumeNumber">Volume number for multi-volume archives</param>
            <param name="lastVolumeNumber">Last volume number for multi-volume archives</param>
            <param name="actualDecompressedSize">Size of decompressed archive item</param>
            <param name="compSize">Size of compressed file</param>        
            <param name="processedBytesCount"></param>
            <param name="rfs">Stream to read compressed data from</param>
            <param name="wfs">Stream to write compressed data to</param>
            <param name="crc32">CRC32 value, must be initialized</param>
            <param name="decrypter">Decrypter object</param>
            <param name="dirItem">Directoy item to dempress</param>
            <returns>True if file was decompressed successfully. Otherwise returns false</returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.InternalDecompressFile(System.IO.Stream,System.IO.Stream,ComponentAce.Compression.Archiver.DirItem)">
            <summary>
            Decompresses archive item.
            </summary>
            <param name="rfs">Stream to read compressed data from</param>
            <param name="wfs">Stream to write compressed data to</param>
            <param name="dirItem">Archive item to decompress</param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.#ctor">
            <summary>
            Creates new instance of the <see cref="T:ComponentAce.Compression.Archiver.BaseArchiver"/> class and initializes its members with default values.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.Finalize">
            <summary>
            Closes current archive file on destruction (Calls <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/>).
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">
            <overloads>
            Opens or creates an archive file.
            </overloads>
            <summary>
            Opens or creates an archive file.
            </summary>
            <example> The following example shows how to add files to archive and extract them:
            <code lang="C#">
             zipForge1.FileName ="C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Set path to folder with the files to archive
             zipForge1.BaseDir = "\\Source";
             // Add all files and directories from the source folder to the archive
             zipForge1.AddFiles("*.*");
             // Set path to the destination folder
             zipForge1.BaseDir = "\\Dest";
             // extract all files in archive
             zipForge1.ExtractFiles("*.*");
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             ' Set archive file name
             ZipForge1.FileName = "C:\TEST\test.zip"
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Set path to folder with the files to archive
             ZipForge1.BaseDir = DemoFolder + "\\Source"
             ' Add all files and directories from the source folder to the archive
             ZipForge1.AddFiles("*.*")
             ' Set path to the destination folder
             ZipForge1.BaseDir = DemoFolder + "\\Dest"
             ' extract all files in archive
             ZipForge1.ExtractFiles("*.*")
             ' Close archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/>
            <remarks>
            Call OpenArchive to open or create an archive file. If file specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property does not exists and <paramref name="fileMode"/> parameter is set to Create (this is by default) or <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InMemory"/> property is set to <b>true</b> then OpenArchive will create and open it. OpenArchive sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Active"/> to <b>true</b>.
            <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/> to close the archive file.</para>
            </remarks>                          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive(System.IO.FileMode)">
            <summary>Opens of creates an archive file with specified <paramref name="fileMode"/> parameter.</summary>
            <param name="fileMode">Specifies open mode constant like in <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)"/>.</param>
            <remarks>
            Call OpenArchive to open or create an archive file. If file specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property does not exists and <paramref name="fileMode"/> parameter is set to Create (this is by default) or <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InMemory"/> property is set to <b>true</b> then OpenArchive will create and open it. OpenArchive sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Active"/> to <b>true</b>.
            <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/> to close the archive file.</para>
            ByVladimir
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive(System.IO.FileMode,System.IO.FileAccess)">
            <summary>
            Opens or creates an archive file with specified <paramref name="fileMode"/>  
            and <paramref name="fileAccess"/> parameters.
            </summary>
            <param name="fileMode">Specifies open mode constant like in <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)"/>.</param>
            <param name="fileAccess">Specifies file access mode like in <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)"/>.</param>
            <remarks>
            Call OpenArchive to open or create an archive file. If file specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property does not exists and <paramref name="fileMode"/> parameter is set to Create (this is by default) or <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InMemory"/> property is set to <b>true</b> then OpenArchive will create and open it. OpenArchive sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Active"/> to <b>true</b>.
            <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/> to close the archive file.</para>
            ByVladimir
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens or creates an archive file with specified <paramref name="fileMode"/>,
            <paramref name="fileAccess"/> and <paramref name="fileShare"/> parameters.
            </summary>
            <param name="fileMode">Specifies open mode constant like in TFileStream.Create or FileOpen function.</param>
            <param name="fileAccess">Specifies file access mode.</param>
            <param name="fileShare">Specifies file share mode.</param>
            <remarks>
            Call OpenArchive to open or create an archive file. If file specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property does not exists and <paramref name="fileMode"/> parameter is set to Create (this is by default) or <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InMemory"/> property is set to <b>true</b> then OpenArchive will create and open it. OpenArchive sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Active"/> to <b>true</b>.
            <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/> to close the archive file.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive(System.IO.Stream,System.Boolean)">
            <summary>
            Opens or creates an archive within a stream.
            </summary>
            <param name="stream">Specifies Stream descendant object with the archive contents.</param>
            <param name="create">Determines if file should be created.</param>
            <remarks>
            Call OpenArchive to open or create an archive in the stream. If <paramref name="create"/> parameter is set to <b>true</b> then OpenArchive will create and open it. OpenArchive sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Active"/> to <b>true</b>.
            <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/> to close the archive file.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive">
             <summary>
             Closes current archive file.
             </summary>
             <example> The following example shows how to add files to archive and extract them:
             <code lang="C#">
              zipForge1.FileName ="C:\\TEST\\test.zip";
              // Create a new archive file
              zipForge1.OpenArchive(FileMode.Create);
              // Set path to folder with the files to archive
              zipForge1.BaseDir = "\\Source";
              // Add all files and directories from the source folder to the archive
              zipForge1.AddFiles("*.*");
              // Set path to the destination folder
              zipForge1.BaseDir = "\\Dest";
              // extract all files in archive
              zipForge1.ExtractFiles("*.*");
              // Close archive
              zipForge1.CloseArchive();
             </code>
             <code lang="vbnet">
              ' Set archive file name
              ZipForge1.FileName = "C:\TEST\test.zip"
              ' Create a new archive file
              ZipForge1.OpenArchive(System.IO.FileMode.Create)
              ' Set path to folder with the files to archive
              ZipForge1.BaseDir = DemoFolder + "\\Source"
              ' Add all files and directories from the source folder to the archive
              ZipForge1.AddFiles("*.*")
              ' Set path to the destination folder
              ZipForge1.BaseDir = DemoFolder + "\\Dest"
              ' extract all files in archive
              ZipForge1.ExtractFiles("*.*")
              ' Close archive
              ZipForge1.CloseArchive()
             </code>
             </example>
             <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive"/>
            <remarks>
             Call CloseArchive to close current archive file. CloseArchive automatically finishes current transaction started by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.BeginUpdate"/> method and sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Active"/> to <b>false</b>.
             <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive"/> to create or open archive file.</para>
             ByVladimir
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.BeginUpdate">
            <summary>
            Begins a transaction for an open archive.
            </summary>
            <example> The following example shows how to use transaction system
            <code lang="C#">
                  zipForge1.FileName = "C:\\TEST\\test.zip";
                  // Create a new archive file            
                  zipForge1.OpenArchive(System.IO.FileMode.Create);
                  // Start a transaction
                  zipForge1.BeginUpdate();
                  // Set path to folder with some HTML files to BaseDir
                  zipForge1.BaseDir = DemoPath + "Source";
                  // Add all files from Source folder to the archive
                  try
                  {
                    zipForge1.AddFiles("*.*");
                  }
                  catch
                  {
                    // If errors occurs rollback transaction. All modifications will be cancelled.            
                    zipForge1.CancelUpdate();
                    // Close archive and exit current procedure                
                    zipForge1.CloseArchive();
                    MessageBox.Show("Error adding all files");
                    return;
                  }
                  // Set path to folder with some HTML files to BaseDir            
                  zipForge1.BaseDir = DemoPath + "Source1\\";
                  // Add all HTML files from Source1 folder to the archive
                  try
                  {
                    zipForge1.AddFiles("*.htm*");
                  }
                  catch
                  {
                    // If errors occurs rollback transaction. All modifications will be cancelled.                
                    zipForge1.CancelUpdate();
                    // Close archive and exit current procedure                
                    zipForge1.CloseArchive();
                    MessageBox.Show("Error adding html files");
                    return;
                  }
                  // Commit a transaction. All modifications will be saved.            
                  zipForge1.EndUpdate();
                  // Set path to destination folder            
                  zipForge1.BaseDir = DemoPath + "Dest";
                  // Extract all files            
                  zipForge1.ExtractFiles("*.*");
                  // Close the archive            
                  zipForge1.CloseArchive();
                </code>
                <code lang="vbnet">
                  zipForge1.FileName = "C:\TEST\test.zip";
                  ' Create a new archive file            
                  zipForge1.OpenArchive(System.IO.FileMode.Create)
                  ' Start a transaction
                  zipForge1.BeginUpdate()
                  ' Set path to folder with some HTML files to BaseDir
                  zipForge1.BaseDir = DemoPath + "Source"
                  ' Add all files from Source folder to the archive
                  Try
                    zipForge1.AddFiles("*.*")
                  Catch
                    ' If errors occurs rollback transaction. All modifications will be cancelled.            
                    zipForge1.CancelUpdate()
                    ' Close archive and exit current procedure                
                    zipForge1.CloseArchive()
                    MessageBox.Show("Error adding all files")
                    Return
                  End Try
                  ' Set path to folder with some HTML files to BaseDir            
                  zipForge1.BaseDir = DemoPath + "Source1\\"
                  ' Add all HTML files from Source1 folder to the archive
                  Try
                    zipForge1.AddFiles("*.htm*")
                  Catch
                    ' If errors occurs rollback transaction. All modifications will be cancelled.                
                    zipForge1.CancelUpdate()
                    ' Close archive and exit current procedure                
                    zipForge1.CloseArchive()
                    MessageBox.Show("Error adding html files")
                    Return
                  End Try
                  ' Commit a transaction. All modifications will be saved.            
                  zipForge1.EndUpdate()
                  ' Set path to destination folder            
                  zipForge1.BaseDir = DemoPath + "Dest"
                  ' Extract all files            
                  zipForge1.ExtractFiles("*.*")
                  ' Close the archive            
                  zipForge1.CloseArchive
            </code>
            </example>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.EndUpdate"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CancelUpdate"/>
            <remarks>
            Call BeginUpdate to start a group of operations called a transaction. All changes made by operations within single transaction can be saved by calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.EndUpdate"/> or cancelled by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CancelUpdate"/>. BeginUpdate sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InUpdate"/> property to <b>true</b>.
            <para>ZipForge.NET transaction system provides archive integrity like reliable database systems.</para>
            <para>Any transaction must be finished before <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles">extracting</see> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles">testing</see> files. Otherwise exception will be raised.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.EndUpdate">
            <summary>
            Finishes a transaction for an open archive.
            </summary>
            <example> The following example shows how to use transaction system
            <code lang="C#">
                  zipForge1.FileName = "C:\\TEST\\test.zip";
                  // Create a new archive file            
                  zipForge1.OpenArchive(System.IO.FileMode.Create);
                  // Start a transaction
                  zipForge1.BeginUpdate();
                  // Set path to folder with some HTML files to BaseDir
                  zipForge1.BaseDir = DemoPath + "Source";
                  // Add all files from Source folder to the archive
                  try
                  {
                    zipForge1.AddFiles("*.*");
                  }
                  catch
                  {
                    // If errors occurs rollback transaction. All modifications will be cancelled.            
                    zipForge1.CancelUpdate();
                    // Close archive and exit current procedure                
                    zipForge1.CloseArchive();
                    MessageBox.Show("Error adding all files");
                    return;
                  }
                  // Set path to folder with some HTML files to BaseDir            
                  zipForge1.BaseDir = DemoPath + "Source1\\";
                  // Add all HTML files from Source1 folder to the archive
                  try
                  {
                    zipForge1.AddFiles("*.htm*");
                  }
                  catch
                  {
                    // If errors occurs rollback transaction. All modifications will be cancelled.                
                    zipForge1.CancelUpdate();
                    // Close archive and exit current procedure                
                    zipForge1.CloseArchive();
                    MessageBox.Show("Error adding html files");
                    return;
                  }
                  // Commit a transaction. All modifications will be saved.            
                  zipForge1.EndUpdate();
                  // Set path to destination folder            
                  zipForge1.BaseDir = DemoPath + "Dest";
                  // Extract all files            
                  zipForge1.ExtractFiles("*.*");
                  // Close the archive            
                  zipForge1.CloseArchive();
                </code>
                <code lang="vbnet">
                  zipForge1.FileName = "C:\TEST\test.zip";
                  ' Create a new archive file            
                  zipForge1.OpenArchive(System.IO.FileMode.Create)
                  ' Start a transaction
                  zipForge1.BeginUpdate()
                  ' Set path to folder with some HTML files to BaseDir
                  zipForge1.BaseDir = DemoPath + "Source"
                  ' Add all files from Source folder to the archive
                  Try
                    zipForge1.AddFiles("*.*")
                  Catch
                    ' If errors occurs rollback transaction. All modifications will be cancelled.            
                    zipForge1.CancelUpdate()
                    ' Close archive and exit current procedure                
                    zipForge1.CloseArchive()
                    MessageBox.Show("Error adding all files")
                    Return
                  End Try
                  ' Set path to folder with some HTML files to BaseDir            
                  zipForge1.BaseDir = DemoPath + "Source1\\"
                  ' Add all HTML files from Source1 folder to the archive
                  Try
                    zipForge1.AddFiles("*.htm*")
                  Catch
                    ' If errors occurs rollback transaction. All modifications will be cancelled.                
                    zipForge1.CancelUpdate()
                    ' Close archive and exit current procedure                
                    zipForge1.CloseArchive()
                    MessageBox.Show("Error adding html files")
                    Return
                  End Try
                  ' Commit a transaction. All modifications will be saved.            
                  zipForge1.EndUpdate()
                  ' Set path to destination folder            
                  zipForge1.BaseDir = DemoPath + "Dest"
                  ' Extract all files            
                  zipForge1.ExtractFiles("*.*")
                  ' Close the archive            
                  zipForge1.CloseArchive
            </code>
            </example>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.BeginUpdate"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CancelUpdate"/>
            <remarks>
            EndUpdate saves all archive modifications made after calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.BeginUpdate"/> and finishes current transaction. EndUpdate sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InUpdate"/> property to <b>false</b>. 
            <para>Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CancelUpdate"/> to cancel archive modifications.</para>
            </remarks> 
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.CancelUpdate">
            <summary>
            Cancels all archive operations made after calling BeginUpdate.
            </summary>
            <example> The following example shows how to use transaction system
            <code lang="C#">
                  zipForge1.FileName = "C:\\TEST\\test.zip";
                  // Create a new archive file            
                  zipForge1.OpenArchive(System.IO.FileMode.Create);
                  // Start a transaction
                  zipForge1.BeginUpdate();
                  // Set path to folder with some HTML files to BaseDir
                  zipForge1.BaseDir = DemoPath + "Source";
                  // Add all files from Source folder to the archive
                  try
                  {
                    zipForge1.AddFiles("*.*");
                  }
                  catch
                  {
                    // If errors occurs rollback transaction. All modifications will be cancelled.            
                    zipForge1.CancelUpdate();
                    // Close archive and exit current procedure                
                    zipForge1.CloseArchive();
                    MessageBox.Show("Error adding all files");
                    return;
                  }
                  // Set path to folder with some HTML files to BaseDir            
                  zipForge1.BaseDir = DemoPath + "Source1\\";
                  // Add all HTML files from Source1 folder to the archive
                  try
                  {
                    zipForge1.AddFiles("*.htm*");
                  }
                  catch
                  {
                    // If errors occurs rollback transaction. All modifications will be cancelled.                
                    zipForge1.CancelUpdate();
                    // Close archive and exit current procedure                
                    zipForge1.CloseArchive();
                    MessageBox.Show("Error adding html files");
                    return;
                  }
                  // Commit a transaction. All modifications will be saved.            
                  zipForge1.EndUpdate();
                  // Set path to destination folder            
                  zipForge1.BaseDir = DemoPath + "Dest";
                  // Extract all files            
                  zipForge1.ExtractFiles("*.*");
                  // Close the archive            
                  zipForge1.CloseArchive();
                </code>
                <code lang="vbnet">
                  zipForge1.FileName = "C:\TEST\test.zip";
                  ' Create a new archive file            
                  zipForge1.OpenArchive(System.IO.FileMode.Create)
                  ' Start a transaction
                  zipForge1.BeginUpdate()
                  ' Set path to folder with some HTML files to BaseDir
                  zipForge1.BaseDir = DemoPath + "Source"
                  ' Add all files from Source folder to the archive
                  Try
                    zipForge1.AddFiles("*.*")
                  Catch
                    ' If errors occurs rollback transaction. All modifications will be cancelled.            
                    zipForge1.CancelUpdate()
                    ' Close archive and exit current procedure                
                    zipForge1.CloseArchive()
                    MessageBox.Show("Error adding all files")
                    Return
                  End Try
                  ' Set path to folder with some HTML files to BaseDir            
                  zipForge1.BaseDir = DemoPath + "Source1\\"
                  ' Add all HTML files from Source1 folder to the archive
                  Try
                    zipForge1.AddFiles("*.htm*")
                  Catch
                    ' If errors occurs rollback transaction. All modifications will be cancelled.                
                    zipForge1.CancelUpdate()
                    ' Close archive and exit current procedure                
                    zipForge1.CloseArchive()
                    MessageBox.Show("Error adding html files")
                    Return
                  End Try
                  ' Commit a transaction. All modifications will be saved.            
                  zipForge1.EndUpdate()
                  ' Set path to destination folder            
                  zipForge1.BaseDir = DemoPath + "Dest"
                  ' Extract all files            
                  zipForge1.ExtractFiles("*.*")
                  ' Close the archive            
                  zipForge1.CloseArchive
            </code>
            </example>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.BeginUpdate"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.EndUpdate"/>
            <remarks>
            Use CancelUpdate to rollback current transaction started by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.BeginUpdate"/>. CancelUpdate clears all archive modifications made after calling BeginUpdate. CancelUpdate sets <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.InUpdate"/> property to <b>false</b>.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddItem(ComponentAce.Compression.Archiver.ArchiveItem)">
            <summary>
            Add a file specified in the archive <paramref name="item"/> to the archive.
            </summary>
            <param name="item">Archive item to be added to the archive</param>
            <remarks>Use AddItem method to add file with the given properties, such as comments, attributes, modification date, etc.</remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFromStream(System.String,System.IO.Stream)">
            <overloads>
            Adds data stored in a stream to the archive.
            </overloads>
            <summary>
            Adds data stored in a stream to the archive.
            </summary>
            <remarks>
            Use AddFromStream to compress data stored in the Stream descendant object like FileStream or MemoryStream to the file inside the archive.
            <para>The position determines starting position in stream for adding data to the archive.</para>
            <para>Count specifies size of the data in stream for adding to the archive. If count = 0 size of the data will be <see cref="P:System.IO.Stream.Length"/> - position. If count &gt; 0 then AddFromStream copies stream data to the internal memory stream before processing.</para>
            <para>By default all Stream contents will be added to the archive.</para>
            <para>The attr parameter specifies file attributes which will be assigned to the stored file.</para>
            <para>While using multiple AddFromStream calls within a single transaction, keep in mind that you may get an error if a stream object is destroyed before the call to the EndUpdate method. Please note that you should use separate stream objects for each AddFromStream call if you don'newDirItem pass processedBytesCount &gt; 0 parameter.</para>
            ByVladimir
            </remarks>          
            <param name="fileName">Specifies file name that will be used to store data from the Stream descendant object.</param>
            <param name="stream">Stream to add data from.</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFromStream(System.String,System.IO.Stream,System.Int64)">
            <summary>
            Adds data stored at a specified position in the stream to the archive.
            </summary>
            <param name="fileName">Specifies file name that will be used to store data from the Stream descendant object.</param>
            <param name="stream">Stream to add data from.</param>
            <param name="position">Determines starting position in stream for adding data to the archive.</param>
            <remarks>
            <para>Use AddFromStream to compress data stored in the Stream descendant object like FileStream or MemoryStream to the file inside the archive.</para>
            ByVladimir
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFromStream(System.String,System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Adds specified amount of data stored at a specified position in the stream to the archive.
            </summary>
            <param name="fileName">Specifies file name that will be used to store data from the Stream descendant object.</param>
            <param name="stream">Stream to add data from.</param>
            <param name="position">Determines starting position in stream for adding data to the archive.</param>
            <param name="count">Count specifies blockSizeToDecompress of the data in stream for adding to the archive.</param>
            <remarks>
            <para>Use AddFromStream to compress data stored in the Stream descendant object like FileStream or MemoryStream to the file inside the archive. </para>
            ByVladimir
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFromBuffer(System.String,System.Byte[],System.Int32)">
            <summary>
            Adds data stored in a memory buffer to the archive.
            </summary>
            <param name="fileName">Specifies file name that will be used to store data from the memory buffer.</param>
            <param name="buffer">Buffer to add data from.</param>
            <param name="count">Specifies blockSizeToDecompress in bytes of the buffer.</param>
            <remarks >
            Use AddFromBuffer to compress data stored in the memory buffer to the file inside the archive. 
            <para>If some errors occurs an exception will be raised.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFromString(System.String,System.String)">
            <summary>
            Adds string to the archive.
            </summary>
            <param name="fileName">Specifies file name that will be used to store string.</param>
            <param name="text">String to add data from.</param>
            <remarks>
            Use AddFromString to compress string to the file inside the archive. 
            <para>If some errors occurs an exception will be raised.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractToStream(System.String,System.IO.Stream)">
            <summary>
            Extracts data stored in the file inside the archive to a <see cref="T:System.IO.Stream">Stream</see> object descendant.
            </summary>
            <param name="fileName">Name of the file being extracted.</param>
            <param name="stream">Stream to extract data to.</param>
            <remarks>
            Use ExtractToStream to decompress data stored in the file inside the archive to a Stream descendant object like FileStream or MemoryStream. 
            <para>Any transaction must be finished before calling ExtractToStream.
            Otherwise an exception will be raised. Also if some other errors occurs an exception will be raised.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractToBuffer(System.String,System.Byte[]@)">
            <summary>
            Decompresses a file with the <paramref name="fileName"/> name stored inside the archive to byte array.
            </summary>
            <param name="fileName">Specifies file name being extracted.</param>
            <param name="buffer">Buffer is an array of bytes where data will be extracted. The method allocates memory for the buffer.</param>
            <returns>Returns the number of data bytes extracted to the buffer.</returns>
            <remarks >
            Use ExtractToBuffer to decompress data stored in the file inside the archive to memory buffer. 
            <para>Any transaction must be finished before calling ExtractToBuffer. Otherwise an exception will be raised. Also if some other errors occurs an exception will be raised.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractToString(System.String,System.String@)">
            <summary>
            Extracts a file stored withing the archive into a string.
            </summary>
            <param name="fileName">Name of the file being extracted.</param>
            <param name="text">String to extract data to.</param>
            <remarks>Use ExtractToString to decompress string from the file inside the archive. 
            <para>Any transaction must be finished before calling ExtractToString. Otherwise an exception will be raised. Also if some other errors occurs an exception will be raised.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.MakeSFX(System.String)">
            <summary>
            Creates a self-extracting (SFX) archive.
            </summary>
            <example>The following example shows how to create a self-extracting (SFX) archive:
            <code lang="C#">
             zipForge1.FileName = "C:\\TEST\\test.zip";
             zipForge1.SFXStub = "SFXStub\sfxstub.exe";
             zipForge1.MakeSFX("Temp\test.exe");
            </code>
            <code lang="vbnet">
             ZipForge1.FileName =  "C:\TEST\test.zip";
             ZipForge1.SFXStub = "SFXStub\sfxstub.exe"
             ZipForge1.MakeSFX("Temp\test.exe")
            </code>
            </example>
            <param name="SFXFileName">Specifies SFX archive name.</param>
            <remarks>
            Call MakeSFX to create the SFX archive from the current archive specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property.
            Set <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.SFXStub"/> property to the executable stub name before calling MakeSFX.
            <para>Look at MakeSFX demo from Demos folder to learn more about creating SFX archives.</para>
            </remarks> 
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)">
            <overloads>
            Finds files stored within the archive.
            </overloads>
            <summary>
            Finds files stored within the archive using <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties.
            </summary>
            <example> The following example shows how to search files stored within the archive:
            <code lang="C#">
             zipForge1.FileName = "C:\\TEST\\test.zip";
             zipForge1.OpenArchive();
             ComponentAce.Compression.ZipForge.ArchiveItem archiveItem = new ComponentAce.Compression.ZipForge.ArchiveItem();
             if (zipForge1.FindFirst("*.*", ref archiveItem))
             {
               do
               {
                 ListViewItem listItem = new ListViewItem();
                 listItem.Text = archiveItem.FileName;
                 ListViewItem.ListViewSubItem subItem = new ListViewItem.ListViewSubItem(listItem, 
                     archiveItem.LastWriteTime.ToShortDateString() + " " + archiveItem.LastWriteTime.ToShortTimeString());
                 listItem.SubItems.Add(subItem);
                 subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.UncompressedSize.ToString());
                 listItem.SubItems.Add(subItem);                    
                 subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.CompressedSize.ToString());
                 listItem.SubItems.Add(subItem);
                 subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.CompressionRate.ToString());
                 listItem.SubItems.Add(subItem);
                 subItem = new ListViewItem.ListViewSubItem(listItem, ((uint)archiveItem.CRC).ToString());
                 listItem.SubItems.Add(subItem);
                 subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.StoredPath);
                 listItem.SubItems.Add(subItem);                    
                 listView1.Items.Add(listItem);
               }
               while (zipForge1.FindNext(ref archiveItem));
             }
             zipForge1.CloseArchive();
             </code>
             <code lang="vbnet">
             zipForge1.FileName = "C:\TEST\test.zip";
             zipForge1.OpenArchive()
             Dim archiveItem As ComponentAce.Compression.ZipForge.ArchiveItem = New ComponentAce.Compression.ZipForge.ArchiveItem()
             If ZipForge1.FindFirst("*.*", archiveItem) Then
               Do                
                 Dim listItem As ListViewItem = New ListViewItem()
                 listItem.Text = archiveItem.FileName
                 Dim subItem As ListViewItem.ListViewSubItem = New ListViewItem.ListViewSubItem(listItem,
                 archiveItem.LastWriteTime.ToShortDateString() + " " + archiveItem.LastWriteTime.ToShortTimeString())
                 listItem.SubItems.Add(subItem)
                 subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.UncompressedSize.ToString())
                 listItem.SubItems.Add(subItem)
                 subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.CompressedSize.ToString())
                 listItem.SubItems.Add(subItem)
                 subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.CompressionRate.ToString())
                 listItem.SubItems.Add(subItem)
                 subItem = New ListViewItem.ListViewSubItem(listItem, (CType(archiveItem.CRC, System.UInt32)).ToString())
                 listItem.SubItems.Add(subItem)
                 subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.StoredPath)
                 listItem.SubItems.Add(subItem)
                 listView1.Items.Add(listItem)
               Loop While ZipForge1.FindNext(archiveItem)
             End If
             zipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use FindFirst and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)">FindNext</see> to find files stored inside the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">open</see> archive file. FindFirst returns <b>true</b> if at least one file meets search conditions, otherwise it returns <b>false</b>. Use FindNext to find other files that meets search conditions.
            <para>After calling FindFirst <paramref name="f"/> parameter will contain parameters of the first found file.</para>
            <para>FindFirst variant with single parameter uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr to specify search conditions and to exclude files from delete operation.</para>
            <para>The fileMask parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. First file that meets FileMask and SearchAttr will be found.</para>
            <para>The searchAttr parameter specifies the special files to include in addition to all normal files</para>
            <para>The exclusionMask specifies files to be excluded from the delete operation.</para>
            ByVladimir
            </remarks>          
            <param name="f">ArchiveItem class.</param>
            <returns><b>true</b> if specified file was successfully found, otherwise it returns <b>false</b>.</returns> 
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)"/>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(System.String,ComponentAce.Compression.Archiver.ArchiveItem@)">
            <summary>
            Finds files stored within the archive using <paramref name="fileMask"/> parameter.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="f">ArchiveItem class.</param>
            <returns><b>true</b> if specified file was successfully found, otherwise it returns <b>false</b>.</returns> 
            <remarks>
            Use FindFirst and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)"/> to find files stored inside the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">open</see> archive file. FindFirst returns <b>true</b> if at least one file meets search conditions, otherwise it returns <b>false</b>. Use FindNext to find other files that meets search conditions.
            <para>After calling FindFirst f parameter will contain parameters of the first found file.</para>
            </remarks> 
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)"/>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(System.String,ComponentAce.Compression.Archiver.ArchiveItem@,System.IO.FileAttributes)">
            <summary>
            Finds files stored within the archive using <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="f">ArchiveItem class.</param>
            <param name="searchAttr">Attributes of the files to search for.</param>
            <returns><b>true</b> if specified file was successfully found, otherwise it returns <b>false</b>.</returns> 
            <remarks>
            Use FindFirst and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)">FindNext</see> to find files stored inside the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">open</see> archive file. FindFirst returns <b>true</b> if at least one file meets search conditions, otherwise it returns <b>false</b>. Use FindNext to find other files that meets search conditions.
            <para>After calling FindFirst <paramref name="f"/> parameter will contain parameters of the first found file.</para>
            </remarks> 
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)"/>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(System.String,ComponentAce.Compression.Archiver.ArchiveItem@,System.IO.FileAttributes,System.String)">
            <summary>
            Finds files stored within the archive using <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="f">ArchiveItem class.</param>
            <param name="searchAttr">Attributes of the files to search for.</param>
            <param name="exclusionMask">Specifies files to be excluded from the search operation.</param>
            <returns><b>true</b> if specified file was successfully found, otherwise it returns <b>false</b>.</returns>  
            <remarks>
            Use FindFirst and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)"/> to find files stored inside the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">open</see> archive file. FindFirst returns <b>true</b> if at least one file meets search conditions, otherwise it returns <b>false</b>. Use FindNext to find other files that meets search conditions.
            <para>After calling FindFirst f parameter will contain parameters of the first found file.</para>
            </remarks> 
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)"/>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)">
             <summary>
             Finds files stored within the archive.
             </summary>
             <example> The following example shows how to search files stored within the archive:
             <code lang="C#">
              zipForge1.FileName = "C:\\TEST\\test.zip";
              zipForge1.OpenArchive();
              ComponentAce.Compression.ZipForge.ArchiveItem archiveItem = new ComponentAce.Compression.ZipForge.ArchiveItem();
              if (zipForge1.FindFirst("*.*", ref archiveItem))
              {
                do
                {
                  ListViewItem listItem = new ListViewItem();
                  listItem.Text = archiveItem.FileName;
                  ListViewItem.ListViewSubItem subItem = new ListViewItem.ListViewSubItem(listItem, 
                      archiveItem.LastWriteTime.ToShortDateString() + " " + archiveItem.LastWriteTime.ToShortTimeString());
                  listItem.SubItems.Add(subItem);
                  subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.UncompressedSize.ToString());
                  listItem.SubItems.Add(subItem);                    
                  subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.CompressedSize.ToString());
                  listItem.SubItems.Add(subItem);
                  subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.CompressionRate.ToString());
                  listItem.SubItems.Add(subItem);
                  subItem = new ListViewItem.ListViewSubItem(listItem, ((uint)archiveItem.CRC).ToString());
                  listItem.SubItems.Add(subItem);
                  subItem = new ListViewItem.ListViewSubItem(listItem, archiveItem.StoredPath);
                  listItem.SubItems.Add(subItem);                    
                  listView1.Items.Add(listItem);
                }
                while (zipForge1.FindNext(ref archiveItem));
              }
              zipForge1.CloseArchive();
              </code>
              <code lang="vbnet">
              zipForge1.FileName = "C:\TEST\test.zip";
              zipForge1.OpenArchive()
              Dim archiveItem As ComponentAce.Compression.ZipForge.ArchiveItem = New ComponentAce.Compression.ZipForge.ArchiveItem()
              If ZipForge1.FindFirst("*.*", archiveItem) Then
                Do                
                  Dim listItem As ListViewItem = New ListViewItem()
                  listItem.Text = archiveItem.FileName
                  Dim subItem As ListViewItem.ListViewSubItem = New ListViewItem.ListViewSubItem(listItem,
                  archiveItem.LastWriteTime.ToShortDateString() + " " + archiveItem.LastWriteTime.ToShortTimeString())
                  listItem.SubItems.Add(subItem)
                  subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.UncompressedSize.ToString())
                  listItem.SubItems.Add(subItem)
                  subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.CompressedSize.ToString())
                  listItem.SubItems.Add(subItem)
                  subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.CompressionRate.ToString())
                  listItem.SubItems.Add(subItem)
                  subItem = New ListViewItem.ListViewSubItem(listItem, (CType(archiveItem.CRC, System.UInt32)).ToString())
                  listItem.SubItems.Add(subItem)
                  subItem = New ListViewItem.ListViewSubItem(listItem, archiveItem.StoredPath)
                  listItem.SubItems.Add(subItem)
                  listView1.Items.Add(listItem)
                Loop While ZipForge1.FindNext(archiveItem)
              End If
              zipForge1.CloseArchive()
             </code>
             </example> 
             <param name="f">ArchiveItem class.</param>
             <returns>FindNext returns <b>true</b> if there is at least one file meets search conditions, otherwise it returns <b>false</b>.</returns>
            <remarks>
             Use FindNext to find files stored inside the open archive file. Use FindNext after calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)"/> only.
             <para>Pass ArchiveItem class found by previous calling of FindFirst or FindNext to the FindNext.
             After calling FindNext f parameter will contain parameters of the next found file.
             </para>
             ByVladimir
            </remarks>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)"/>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.RenameFile(System.String,System.String)">
            <summary>
            Renames file stored within the current archive file.
            </summary>
            <param name="oldName">Specifies file to be renamed.</param>
            <param name="newName">Specifies new name for the file.</param>
            <returns><b>true</b> if file was successfully renamed, otherwise it returns <b>false</b>.</returns>
            <remarks>
            Call RenameFile to rename file stored in the open archive.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ChangeFilesAttr(System.String,System.IO.FileAttributes)">
            <summary>
            Changes file attributes for files stored within the current archive file.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="newAttr">Specifies new file attributes.</param>
            <remarks>
            Call ChangeFilesAttr to change file attributes for files stored within the current archive file.
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. All files that meet <paramref name="fileMask"/>  will be processed.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ChangeFilesIntAttr(System.String,System.UInt16)">
            <summary>
            Change files attributes by mask
            </summary>
            <param name="fileMask">Specifies the file mask</param>
            <param name="newAttr">New file attribute</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ChangeFilesComment(System.String,System.String)">
            <summary>
            Changes file comment for files stored within the current archive file.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="newComment">Specifies new file comment.</param>
            <remarks>
            Call ChangeFilesComment to change file attributes for files stored within the current archive file.
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. All files that meets <paramref name="fileMask"/> will be processed.</para>
            <para>To change the comment of the whole archive file use the Comment property.</para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.IsFilePasswordValid(System.String,System.String)">
            <summary>
            Indicates whether the password is valid for specified encrypted file in archive.
            </summary>
            <param name="fileName">Specifies file name being tested.</param>
            <param name="password">The password parameter is a password to check.</param>
            <returns>True if the password is valid.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles">
            <overloads>
            Adds files to the archive.
            </overloads>
            <summary>
            Adds files to the archive specified by <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties.
            </summary>
            <example> The following example shows how to add files to archive and extract them:
            <code lang="C#">
             zipForge1.FileName ="C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Set path to folder with the files to archive
             zipForge1.BaseDir = "\\Source";
             // Add all files and directories from the source folder to the archive
             zipForge1.AddFiles("*.*");
             // Set path to the destination folder
             zipForge1.BaseDir = "\\Dest";
             // extract all files in archive
             zipForge1.ExtractFiles("*.*");
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             ' Set archive file name
             ZipForge1.FileName = "C:\TEST\test.zip"
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Set path to folder with the files to archive
             ZipForge1.BaseDir = DemoFolder + "\\Source"
             ' Add all files and directories from the source folder to the archive
             ZipForge1.AddFiles("*.*")
             ' Set path to the destination folder
             ZipForge1.BaseDir = DemoFolder + "\\Dest"
             ' extract all files in archive
             ZipForge1.ExtractFiles("*.*")
             ' Close archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use AddFiles to add files to the open archive file. If you need to delete source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/> instead of AddFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, AddFiles will search files recursively.
            <para>AddFiles variant without parameters uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr properties to specify search conditions and to exclude files from add operation.</para>
            <para>The fileMask parameter is the directory and file name mask, including wildcard characters. For example, "C:\TEST\*.*" specifies all files in the C:\TEST directory. All files that meets fileMask and searchAttr will be added to the archive.</para>
            <para>The searchAttr parameter specifies the special files to include in addition to all normal files.</para>
            <para>The exclusionMask specifies files to be excluded from the add operation.</para>
            <para>If you need to add certain files without compression set <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.NoCompressionMasks"/> property. If some errors occurs an exception will be raised. Write an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event handler to perform your own error handling.</para>
            <para>If you need to change the name of the added file, use <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnStoreFile"/> event handler.</para>
            ByVladimir
            </remarks>          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles(System.String)">
            <summary>
            Adds files specified by the <paramref name="fileMask"/> parameter to the archive.
            </summary>          
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <remarks>
            Use AddFiles to add files to the open archive file. If you need to delete source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/> instead of AddFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, AddFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles(System.String,System.IO.FileAttributes)">
            <summary>
            Adds files specified by <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters to the archive.
            </summary>          
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
            <remarks>
            Use AddFiles to add files to the open archive file. If you need to delete source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/> instead of AddFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, AddFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles(System.String,System.IO.FileAttributes,System.String)">
            <summary>
            Adds files specified by <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters to the archive.
            </summary>        
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
            <param name="exclusionMask">Specifies files to be excluded from add operation.</param>
            <remarks>
            Use AddFiles to add files to the open archive file. If you need to delete source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/> instead of AddFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, AddFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles">
            <overloads>
            Adds files to the archive and deletes original files.
            </overloads>
            <summary>
            Moves files to the archive using <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties.
            </summary>
            <example> The following example shows how to handle the archive file:
            <code lang="C#">
             zipForge1.FileName = "C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Let's encrypt all files
             zipForge1.Password = "The password";
             // Set path to folder with some text files to BaseDir
             zipForge1.BaseDir = "Source";
             // Do not compress MPEG3 files
             zipForge1.NoCompressionMasks.Add("*.mp3");
             // Add all files and directories from Source excluding text files to the archive
             zipForge1.AddFiles("*.*", FileAttributes.Archive| 
             FileAttributes.Normal | FileAttributes.Directory, "*.txt");// Set path to destination folder            
             zipForge1.BaseDir = "Dest";
             // Extract all files and directories from the archive to BaseDir
             // After extracting directory Dest should contain all files from folder
             // Source excluding *.txt files
             zipForge1.ExtractFiles("*.*");
             // Use full path
             zipForge1.Options.StorePath = StorePathMode.FullPath;
             // Set path to destination folder
             zipForge1.BaseDir = "Source1";
             // Move all text files from Source1 to the archive
             // After moving directory Source1 should not contain any text files
             zipForge1.MoveFiles("*.txt", FileAttributes.Normal | FileAttributes.Archive);
             // Set path to current drive
             zipForge1.BaseDir = Directory.GetDirectoryRoot(Directory.GetCurrentDirectory());
             // Overwrite all files
             zipForge1.Options.Overwrite = OverwriteMode.Always;
             // Update all files excluding 1???.newDirItem* from Source1
             zipForge1.UpdateFiles(DemoFolder + "\\Source1\\*.*", FileAttributes.Archive | FileAttributes.Normal,       "2???.newDirItem*");
             // Set temporary directory
             zipForge1.TempDir = "Temp";
             // Test all files and directories in the archive
             try
             {
               zipForge1.TestFiles("*.*");
             }
             catch
             {
               MessageBox.Show("Archive is corrupted");
             }
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             zipForge1.FileName = "C:\TEST\test.zip";
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Let's encrypt all files
             ZipForge1.Password = "The password"
             ' Set path to folder with some text files to BaseDir
             ZipForge1.BaseDir = "Source"
             ' Do not compress MPEG3 files
             ZipForge1.NoCompressionMasks.Add("*.mp3")
             ' Add all files and directories from Source excluding text files to the archive
             ZipForge1.AddFiles("*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Directory, "*.txt")
             ' Set path to destination folder            
             ZipForge1.BaseDir = "Dest"
             ' Extract all files and directories from the archive to BaseDir
             ' After extracting directory Dest should contain all files from folder
             ' Source excluding *.txt files
             ZipForge1.ExtractFiles("*.*")
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.FullPath
             ' Set path to destination folder
             ZipForge1.BaseDir = "Source1"
             ' Move all text files from Source1 to the archive
             ' After moving directory Source1 should not contain any text files
             ZipForge1.MoveFiles("*.txt", System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Archive)
             ' Set path to current drive
             ZipForge1.BaseDir = System.IO.Directory.GetDirectoryRoot(System.IO.Directory.GetCurrentDirectory())
             ' Overwrite all files
             ZipForge1.Options.Overwrite = ComponentAce.Compression.ZipForge.OverwriteMode.Always
             ' Update all files excluding 1???.newDirItem* from Source1
             ZipForge1.UpdateFiles(DemoFolder + "\Source1\*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal, "2???.newDirItem*")
             ' Set temporary directory
             ZipForge1.TempDir = DemoFolder + "Temp"
             ' Test all files and directories in the archive
             Try
               ZipForge1.TestFiles("*.*")
             Catch
               MessageBox.Show("Archive is corrupted")
             End Try
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.RelativePath
             ZipForge1.BaseDir = "Dest1"
             ' Extract all files to Dest1
             ZipForge1.ExtractFiles("*.*")
             ' Close the archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use MoveFiles to move files to the open archive file. MoveFiles deletes all files after they are added to the archive. If you need to add files to the archive without deleting source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/> instead of MoveFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, MoveFiles will search files recursively.
            <para>MoveFiles variant without parameters uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr to specify search conditions and to exclude files from move operation.</para>
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, 'C:\TEST\*.*' specifies all files in the C:\TEST directory. All files that meets FileMask and SearchAttr will be moved to the archive.</para>
            <para>The <paramref name="searchAttr"/> parameter specifies the special files to include in addition to all normal files.</para>
            <para>The <paramref name="exclusionMask"/> specifies files to be excluded from the move operation.</para>
            <para>If you need to move certain files without compression set <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.NoCompressionMasks"/> property. If some errors occurs an exception will be raised. Write an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event handler to perform your own error handling.</para>
            </remarks>          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles(System.String)">
             <summary>
             Moves files to archive using <paramref name="fileMask"/> parameter.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <remarks>
             Use MoveFiles to move files to the open archive file. MoveFiles deletes all files after they will be added to the archive. If you need to add files to the archive without deleting source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/> instead of MoveFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, MoveFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles(System.String,System.IO.FileAttributes)">
             <summary>
             Moves files to archive using <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
             <remarks>
             Use MoveFiles to move files to the open archive file. MoveFiles deletes all files after they will be added to the archive. If you need to add files to the archive without deleting source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/> instead of MoveFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, MoveFiles will search files recursively.
            </remarks>           
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles(System.String,System.IO.FileAttributes,System.String)">
             <summary>
             Moves files to archive using <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
             <param name="exclusionMask">Specifies files to be excluded from the move operation.</param>
             <remarks>
             Use MoveFiles to move files to the open archive file. MoveFiles deletes all files after they will be added to the archive. If you need to add files to the archive without deleting source files, use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/> instead of MoveFiles. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, MoveFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles">
            <overloads>
            Deletes files stored within the archive.
            </overloads>
            <summary>
            Deletes files stored within the archive specified by <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties.
            </summary>
            <example> The following example shows how to handle the archive file:
            <code lang="C#">
             zipForge1.FileName = "C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Let's encrypt all files
             zipForge1.Password = "The password";
             // Set path to folder with some text files to BaseDir
             zipForge1.BaseDir = "Source";
             // Do not compress MPEG3 files
             zipForge1.NoCompressionMasks.Add("*.mp3");
             // Add all files and directories from Source excluding text files to the archive
             zipForge1.AddFiles("*.*", FileAttributes.Archive| 
             FileAttributes.Normal | FileAttributes.Directory, "*.txt");// Set path to destination folder            
             zipForge1.BaseDir = "Dest";
             // Extract all files and directories from the archive to BaseDir
             // After extracting directory Dest should contain all files from folder
             // Source excluding *.txt files
             zipForge1.ExtractFiles("*.*");
             // Use full path
             zipForge1.Options.StorePath = StorePathMode.FullPath;
             // Set path to destination folder
             zipForge1.BaseDir = "Source1";
             // Move all text files from Source1 to the archive
             // After moving directory Source1 should not contain any text files
             zipForge1.MoveFiles("*.txt", FileAttributes.Normal | FileAttributes.Archive);
             // Set path to current drive
             zipForge1.BaseDir = Directory.GetDirectoryRoot(Directory.GetCurrentDirectory());
             // Overwrite all files
             zipForge1.Options.Overwrite = OverwriteMode.Always;
             // Update all files excluding 1???.newDirItem* from Source1
             zipForge1.UpdateFiles(DemoFolder + "\\Source1\\*.*", FileAttributes.Archive | FileAttributes.Normal,       "2???.newDirItem*");
             // Set temporary directory
             zipForge1.TempDir = "Temp";
             // Test all files and directories in the archive
             try
             {
               zipForge1.TestFiles("*.*");
             }
             catch
             {
               MessageBox.Show("Archive is corrupted");
             }
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             zipForge1.FileName = "C:\TEST\test.zip";
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Let's encrypt all files
             ZipForge1.Password = "The password"
             ' Set path to folder with some text files to BaseDir
             ZipForge1.BaseDir = "Source"
             ' Do not compress MPEG3 files
             ZipForge1.NoCompressionMasks.Add("*.mp3")
             ' Add all files and directories from Source excluding text files to the archive
             ZipForge1.AddFiles("*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Directory, "*.txt")
             ' Set path to destination folder            
             ZipForge1.BaseDir = "Dest"
             ' Extract all files and directories from the archive to BaseDir
             ' After extracting directory Dest should contain all files from folder
             ' Source excluding *.txt files
             ZipForge1.ExtractFiles("*.*")
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.FullPath
             ' Set path to destination folder
             ZipForge1.BaseDir = "Source1"
             ' Move all text files from Source1 to the archive
             ' After moving directory Source1 should not contain any text files
             ZipForge1.MoveFiles("*.txt", System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Archive)
             ' Set path to current drive
             ZipForge1.BaseDir = System.IO.Directory.GetDirectoryRoot(System.IO.Directory.GetCurrentDirectory())
             ' Overwrite all files
             ZipForge1.Options.Overwrite = ComponentAce.Compression.ZipForge.OverwriteMode.Always
             ' Update all files excluding 1???.newDirItem* from Source1
             ZipForge1.UpdateFiles(DemoFolder + "\Source1\*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal, "2???.newDirItem*")
             ' Set temporary directory
             ZipForge1.TempDir = DemoFolder + "Temp"
             ' Test all files and directories in the archive
             Try
               ZipForge1.TestFiles("*.*")
             Catch
               MessageBox.Show("Archive is corrupted")
             End Try
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.RelativePath
             ZipForge1.BaseDir = "Dest1"
             ' Extract all files to Dest1
             ZipForge1.ExtractFiles("*.*")
             ' Close the archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use DeleteFiles to delete files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, DeleteFiles will search files recursively.
            <para>DeleteFiles variant without parameters uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr to specify search conditions and to exclude files from delete operation.</para>
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. All files that meets FileMask and SearchAttr will be deleted.</para>
            <para>The <paramref name="searchAttr"/> parameter specifies the special files to include in addition to all normal files.</para>
            <para>The <paramref name="exclusionMask"/> specifies files to be excluded from the delete operation.</para>
            <para> If some errors occur an exception will be raised. Write an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event handler to perform your own error handling.</para>
            </remarks>          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles(System.String)">
             <summary>
             Deletes files stored within the archive and specified by the <paramref name="fileMask"/> parameter.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <remarks>
             Use DeleteFiles to delete files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, DeleteFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles(System.String,System.IO.FileAttributes)">
             <summary>
             Deletes files stored within the archive and specified by <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
             <remarks>
             Use DeleteFiles to delete files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, DeleteFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles(System.String,System.IO.FileAttributes,System.String)">
             <summary>
             Deletes files stored within the archive and specified by <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
             <param name="exclusionMask">Specifies files to be excluded from the delete operation.</param>
             <remarks>
             Use DeleteFiles to delete files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, DeleteFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles">
            <overloads>
            Updates files stored within the archive.
            </overloads>
            <summary>
            Updates files stored within the archive using <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties.
            </summary>
            <example> The following example shows how to handle the archive file:
            <code lang="C#">
             zipForge1.FileName = "C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Let's encrypt all files
             zipForge1.Password = "The password";
             // Set path to folder with some text files to BaseDir
             zipForge1.BaseDir = "Source";
             // Do not compress MPEG3 files
             zipForge1.NoCompressionMasks.Add("*.mp3");
             // Add all files and directories from Source excluding text files to the archive
             zipForge1.AddFiles("*.*", FileAttributes.Archive| 
             FileAttributes.Normal | FileAttributes.Directory, "*.txt");// Set path to destination folder            
             zipForge1.BaseDir = "Dest";
             // Extract all files and directories from the archive to BaseDir
             // After extracting directory Dest should contain all files from folder
             // Source excluding *.txt files
             zipForge1.ExtractFiles("*.*");
             // Use full path
             zipForge1.Options.StorePath = StorePathMode.FullPath;
             // Set path to destination folder
             zipForge1.BaseDir = "Source1";
             // Move all text files from Source1 to the archive
             // After moving directory Source1 should not contain any text files
             zipForge1.MoveFiles("*.txt", FileAttributes.Normal | FileAttributes.Archive);
             // Set path to current drive
             zipForge1.BaseDir = Directory.GetDirectoryRoot(Directory.GetCurrentDirectory());
             // Overwrite all files
             zipForge1.Options.Overwrite = OverwriteMode.Always;
             // Update all files excluding 1???.newDirItem* from Source1
             zipForge1.UpdateFiles(DemoFolder + "\\Source1\\*.*", FileAttributes.Archive | FileAttributes.Normal,       "2???.newDirItem*");
             // Set temporary directory
             zipForge1.TempDir = "Temp";
             // Test all files and directories in the archive
             try
             {
               zipForge1.TestFiles("*.*");
             }
             catch
             {
               MessageBox.Show("Archive is corrupted");
             }
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             zipForge1.FileName = "C:\TEST\test.zip";
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Let's encrypt all files
             ZipForge1.Password = "The password"
             ' Set path to folder with some text files to BaseDir
             ZipForge1.BaseDir = "Source"
             ' Do not compress MPEG3 files
             ZipForge1.NoCompressionMasks.Add("*.mp3")
             ' Add all files and directories from Source excluding text files to the archive
             ZipForge1.AddFiles("*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Directory, "*.txt")
             ' Set path to destination folder            
             ZipForge1.BaseDir = "Dest"
             ' Extract all files and directories from the archive to BaseDir
             ' After extracting directory Dest should contain all files from folder
             ' Source excluding *.txt files
             ZipForge1.ExtractFiles("*.*")
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.FullPath
             ' Set path to destination folder
             ZipForge1.BaseDir = "Source1"
             ' Move all text files from Source1 to the archive
             ' After moving directory Source1 should not contain any text files
             ZipForge1.MoveFiles("*.txt", System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Archive)
             ' Set path to current drive
             ZipForge1.BaseDir = System.IO.Directory.GetDirectoryRoot(System.IO.Directory.GetCurrentDirectory())
             ' Overwrite all files
             ZipForge1.Options.Overwrite = ComponentAce.Compression.ZipForge.OverwriteMode.Always
             ' Update all files excluding 1???.newDirItem* from Source1
             ZipForge1.UpdateFiles(DemoFolder + "\Source1\*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal, "2???.newDirItem*")
             ' Set temporary directory
             ZipForge1.TempDir = DemoFolder + "Temp"
             ' Test all files and directories in the archive
             Try
               ZipForge1.TestFiles("*.*")
             Catch
               MessageBox.Show("Archive is corrupted")
             End Try
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.RelativePath
             ZipForge1.BaseDir = "Dest1"
             ' Extract all files to Dest1
             ZipForge1.ExtractFiles("*.*")
             ' Close the archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use UpdateFiles to update files stored within the open archive file. UpdateFiles searches for external files specified by <paramref name="fileMask"/>, <paramref name="searchAttr"/> and <paramref name="exclusionMask"/> parameters and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.BaseDir"/> property and synchronizes them with files stored within the archive. UpdateFiles uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.OverwriteMode to determine how to overwrite existing files inside the archive with external files from BaseDir. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, UpdateFiles will search files recursively.
            <para>UpdateFiles variant without parameters uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr to specify search conditions and to exclude files from update operation.</para>
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. All files that meets FileMask and SearchAttr will be updated.</para>
            <para>The <paramref name="searchAttr"/> parameter specifies the special files to include in addition to all normal files.</para>
            <para>The <paramref name="exclusionMask"/> specifies files to be excluded from the update operation.</para>
            <para>If you need to update certain files without compression set <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.NoCompressionMasks"/> property. If some errors occurs an exception will be raised. Write an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event handler to perform your own error handling. </para>
            ByVladimir
            </remarks>          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles(System.String)">
             <summary>
             Updates files stored within the archive using <paramref name="fileMask"/> parameter.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <remarks>
             Use UpdateFiles to update files stored within the open archive file. UpdateFiles searches for external files specified by <paramref name="fileMask"/>, <paramref name="searchAttr"/> and <paramref name="exclusionMask"/> parameters and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.BaseDir"/> property and synchronizes them with files stored within the archive. UpdateFiles uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.OverwriteMode to determine how to overwrite existing files inside the archive with external files from BaseDir. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, UpdateFiles will search files recursively.
            </remarks>           
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles(System.String,System.IO.FileAttributes)">
             <summary>
             Updates files stored within the archive using <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
             <remarks>
             Use UpdateFiles to update files stored within the open archive file. UpdateFiles searches for external files specified by <paramref name="fileMask"/>, <paramref name="searchAttr"/> and <paramref name="exclusionMask"/> parameters and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.BaseDir"/> property and synchronizes them with files stored within the archive. UpdateFiles uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.OverwriteMode to determine how to overwrite existing files inside the archive with external files from BaseDir. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, UpdateFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles(System.String,System.IO.FileAttributes,System.String)">
             <summary>
             Updates files stored within the archive using <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters.
             </summary>
             <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
             <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
             <param name="exclusionMask">Specifies files to be excluded from the move operation.</param>
             <remarks>
             Use UpdateFiles to update files stored within the open archive file. UpdateFiles searches for external files specified by <paramref name="fileMask"/>, <paramref name="searchAttr"/> and <paramref name="exclusionMask"/> parameters and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.BaseDir"/> property and synchronizes them with files stored within the archive. UpdateFiles uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.OverwriteMode to determine how to overwrite existing files inside the archive with external files from BaseDir. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, UpdateFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles">
            <overloads>
            Tests files stored within the archive. 
            </overloads>
            <summary>
            Tests files stored within the archive using <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties.
            </summary>
            <example> The following example shows how to handle the archive file:
            <code lang="C#">
             zipForge1.FileName = "C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Let's encrypt all files
             zipForge1.Password = "The password";
             // Set path to folder with some text files to BaseDir
             zipForge1.BaseDir = "Source";
             // Do not compress MPEG3 files
             zipForge1.NoCompressionMasks.Add("*.mp3");
             // Add all files and directories from Source excluding text files to the archive
             zipForge1.AddFiles("*.*", FileAttributes.Archive| 
             FileAttributes.Normal | FileAttributes.Directory, "*.txt");// Set path to destination folder            
             zipForge1.BaseDir = "Dest";
             // Extract all files and directories from the archive to BaseDir
             // After extracting directory Dest should contain all files from folder
             // Source excluding *.txt files
             zipForge1.ExtractFiles("*.*");
             // Use full path
             zipForge1.Options.StorePath = StorePathMode.FullPath;
             // Set path to destination folder
             zipForge1.BaseDir = "Source1";
             // Move all text files from Source1 to the archive
             // After moving directory Source1 should not contain any text files
             zipForge1.MoveFiles("*.txt", FileAttributes.Normal | FileAttributes.Archive);
             // Set path to current drive
             zipForge1.BaseDir = Directory.GetDirectoryRoot(Directory.GetCurrentDirectory());
             // Overwrite all files
             zipForge1.Options.Overwrite = OverwriteMode.Always;
             // Update all files excluding 1???.newDirItem* from Source1
             zipForge1.UpdateFiles(DemoFolder + "\\Source1\\*.*", FileAttributes.Archive | FileAttributes.Normal,       "2???.newDirItem*");
             // Set temporary directory
             zipForge1.TempDir = "Temp";
             // Test all files and directories in the archive
             try
             {
               zipForge1.TestFiles("*.*");
             }
             catch
             {
               MessageBox.Show("Archive is corrupted");
             }
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             zipForge1.FileName = "C:\TEST\test.zip";
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Let's encrypt all files
             ZipForge1.Password = "The password"
             ' Set path to folder with some text files to BaseDir
             ZipForge1.BaseDir = "Source"
             ' Do not compress MPEG3 files
             ZipForge1.NoCompressionMasks.Add("*.mp3")
             ' Add all files and directories from Source excluding text files to the archive
             ZipForge1.AddFiles("*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Directory, "*.txt")
             ' Set path to destination folder            
             ZipForge1.BaseDir = "Dest"
             ' Extract all files and directories from the archive to BaseDir
             ' After extracting directory Dest should contain all files from folder
             ' Source excluding *.txt files
             ZipForge1.ExtractFiles("*.*")
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.FullPath
             ' Set path to destination folder
             ZipForge1.BaseDir = "Source1"
             ' Move all text files from Source1 to the archive
             ' After moving directory Source1 should not contain any text files
             ZipForge1.MoveFiles("*.txt", System.IO.FileAttributes.Normal Or System.IO.FileAttributes.Archive)
             ' Set path to current drive
             ZipForge1.BaseDir = System.IO.Directory.GetDirectoryRoot(System.IO.Directory.GetCurrentDirectory())
             ' Overwrite all files
             ZipForge1.Options.Overwrite = ComponentAce.Compression.ZipForge.OverwriteMode.Always
             ' Update all files excluding 1???.newDirItem* from Source1
             ZipForge1.UpdateFiles(DemoFolder + "\Source1\*.*", System.IO.FileAttributes.Archive Or System.IO.FileAttributes.Normal, "2???.newDirItem*")
             ' Set temporary directory
             ZipForge1.TempDir = DemoFolder + "Temp"
             ' Test all files and directories in the archive
             Try
               ZipForge1.TestFiles("*.*")
             Catch
               MessageBox.Show("Archive is corrupted")
             End Try
             ' Use full path
             ZipForge1.Options.StorePath = ComponentAce.Compression.ZipForge.StorePathMode.RelativePath
             ZipForge1.BaseDir = "Dest1"
             ' Extract all files to Dest1
             ZipForge1.ExtractFiles("*.*")
             ' Close the archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use TestFiles to test files stored within the open archive file. Selected files will be extracted to temporary directory specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.TempDir"/> property. TestFiles will delete these temporary files after testing. If errors occurs during test operation <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event will be triggered. If there is no event handler available then exception will be raised. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, TestFiles will search files recursively.
            <para>TestFiles variant without parameters uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr to specify search conditions and to exclude files from test operation.</para>
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. All files that meets FileMask and SearchAttr will be tested.</para>
            <para>The <paramref name="searchAttr"/> parameter specifies the special files to include in addition to all normal files.</para>
            <para>The <paramref name="exclusionMask"/> specifies files to be excluded from the test operation.</para>
            <para>Any transaction must be finished before calling TestFiles. Otherwise an exception will be raised. Also if some other errors occurs an exception will be raised. Write an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event handler to perform your own error handling.</para>
            </remarks>          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles(System.String)">
            <summary>
            Tests files stored within the archive using <paramref name="fileMask"/> parameter.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <remarks>
            Use TestFiles to test files stored within the open archive file. Selected files will be extracted to temporary directory specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.TempDir"/> property. TestFiles will delete these temporary files after testing. If errors occurs during test operation <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event will be triggered. If there is no event handler available then exception will be raised. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, TestFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles(System.String,System.IO.FileAttributes)">
            <summary>
            Tests files stored within the archive using <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
            <remarks>
            Use TestFiles to test files stored within the open archive file. Selected files will be extracted to temporary directory specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.TempDir"/> property. TestFiles will delete these temporary files after testing. If errors occurs during test operation <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event will be triggered. If there is no event handler available then exception will be raised. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, TestFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles(System.String,System.IO.FileAttributes,System.String)">
            <summary>
            Tests files stored within the archive using <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="searchAttr">Specifies the special files to include in addition to all normal files.</param>
            <param name="exclusionMask">Specifies files to be excluded from the test operation.</param>
            <remarks>
            Use TestFiles to test files stored within the open archive file. Selected files will be extracted to temporary directory specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.TempDir"/> property. TestFiles will delete these temporary files after testing. If errors occurs during test operation <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event will be triggered. If there is no event handler available then exception will be raised. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, TestFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.RepairArchive">
            <overloads>
            Repairs the current archive file.
            </overloads>
            <summary>
            Repairs the current archive file.
            </summary>
            <remarks>
            Call RepairArchive to repair damaged archive file. 
            <para>OutputFileName parameter specifies the file name to write the repaired file to.</para>
            <para>By default OutputFileName is blank and original archive file is replaced by repaired one.</para>
            </remarks>
            <remarks>
            Call RepairArchive to repair damaged archive file. 
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.RepairArchive(System.String)">
            <summary>
            Saves repaired archive to file specified by outputFileName parameter.
            </summary>
            <param name="outputFileName">Specifies the file name to write the repaired file to.</param>
            <remarks>
            Call RepairArchive to repair damaged archive file. 
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles">
            <overloads>
            Extracts files from the archive.
            </overloads>
            <summary>
            Extracts files specified by <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> properties from the archive.
            </summary>
            <example> The following example shows how to add files to archive and extract them:
            <code lang="C#">
             zipForge1.FileName ="C:\\TEST\\test.zip";
             // Create a new archive file
             zipForge1.OpenArchive(FileMode.Create);
             // Set path to folder with the files to archive
             zipForge1.BaseDir = "\\Source";
             // Add all files and directories from the source folder to the archive
             zipForge1.AddFiles("*.*");
             // Set path to the destination folder
             zipForge1.BaseDir = "\\Dest";
             // extract all files in archive
             zipForge1.ExtractFiles("*.*");
             // Close archive
             zipForge1.CloseArchive();
            </code>
            <code lang="vbnet">
             ' Set archive file name
             ZipForge1.FileName = "C:\TEST\test.zip"
             ' Create a new archive file
             ZipForge1.OpenArchive(System.IO.FileMode.Create)
             ' Set path to folder with the files to archive
             ZipForge1.BaseDir = DemoFolder + "\\Source"
             ' Add all files and directories from the source folder to the archive
             ZipForge1.AddFiles("*.*")
             ' Set path to the destination folder
             ZipForge1.BaseDir = DemoFolder + "\\Dest"
             ' extract all files in archive
             ZipForge1.ExtractFiles("*.*")
             ' Close archive
             ZipForge1.CloseArchive()
            </code>
            </example>
            <remarks>
            Use ExtractFiles to extract files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, ExtractFiles will search files recursively.
            <para>
            ExtractFiles variant without parameters uses <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr properties to specify search conditions and to exclude files from add operation.
            ExtractFiles variant with parameters uses procedure parameters and ignores <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/>, <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/> and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.SearchAttr properties.
            </para>
            <para>The <paramref name="fileMask"/> parameter is the directory and file name mask, including wildcard characters. For example, "TEST\\*.*" specifies all files in the TEST directory stored within the archive file. All files that meets FileMask and SearchAttr will be extracted from the archive.If FileMask is a blank string, no files will be extracted.</para>
            <para>The <paramref name="searchAttr"/> parameter specifies the special files to include in addition to all normal files.</para>
            <para>The <paramref name="exclusionMask"/> specifies files to be excluded from the extract operation.</para>
            <para>Any transaction must be finished before calling ExtractFiles. Otherwise an exception will be raised. Also if some other errors occurs an exception will be raised. Write an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event handler to perform your own error handling.</para>
            <para>Use <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExtractCorruptedFiles"/> property to specify whether extracting of corrupted files is allowed.</para>
            <para>If you need to change the name of the extracted file, use <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnExtractFile"/> event handler.</para>
            </remarks>          
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles(System.String)">
            <summary>
            Extracts files specified by the <paramref name="fileMask"/> parameter.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <remarks>
            Use ExtractFiles to extract files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, ExtractFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles(System.String,System.IO.FileAttributes)">
            <summary>
            Extracts files specified by <paramref name="fileMask"/> and <paramref name="seachAttr"/> parameters.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="searchAttr">Attributes of the files to search for.</param>
            <remarks>
            Use ExtractFiles to extract files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, ExtractFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles(System.String,System.IO.FileAttributes,System.String)">
            <summary>
            Extracts files specified by <paramref name="fileMask"/>, <paramref name="seachAttr"/> and <paramref name="exlusionMask"/> parameters.
            </summary>
            <param name="fileMask">The directory and file name mask, including wildcard characters.</param>
            <param name="searchAttr">Attributes of the files to search for.</param>
            <param name="exclusionMask">Specifies files to be excluded from the extract operation.</param>
            <remarks>
            Use ExtractFiles to extract files from the open archive file. If <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Recurse is set to <b>true</b>, ExtractFiles will search files recursively.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.IsValidArchiveFile">
            <summary>
            Indicates whether archive is valid. 
            </summary>
            <returns><b>true</b> if the file is a valid archive; otherwise returns <b>false</b>.</returns>
            <remarks>
            Use IsValidArchiveFile to determine whether the file has valid format before opening the archive. 
            <para>The <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property is used to specify the file name of the file being checked.</para> 
            <para>Note: Call to this method when archive is open will raise an exception.</para> 
            ByVladimir
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection of <see cref="T:ComponentAce.Compression.Archiver.ArchiveItem"/> in the central directory.
            </summary>
            <seealso cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Current"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveNext"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.Reset"/>
            <returns>An IEnumerator object that can be used to iterate through the collection.</returns>
            <remarks>
            <para>Central directory is a term from ZIP format terminology. It contains all files and directories stored in the archive.</para>
            ByVladimir</remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveNext">
            <summary>
            Advances the enumerator to the next <see cref="T:ComponentAce.Compression.Archiver.ArchiveItem"/> in the central directory.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.GetEnumerator"/>
            <seealso cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Current"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.Reset"/>
            <returns><b>true</b> if the enumerator was successfully advanced to the next element; 
            <b>false</b> if the enumerator already points to the end of the collection.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseArchiver.Reset">
            <summary>
            Sets the enumerator to its initial position, which is the first element in the central directory.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.GetEnumerator"/>
            <seealso cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Current"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveNext"/>
            <remarks>
            <para>Central directory is a term from ZIP format terminology. It contains all files and directories stored in the archive.</para>
            ByVladimir</remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnOverallProgress">
            <summary>
            Occurs when archive operation with a group of files updates a progress indication value.
            </summary>
            <remarks>
            Write an OnOverallProgress event handler to display progress of the operation on a group of files or to cancel it. OnOverallProgress event is triggered by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> when current archive operation on a group of files updates a progress indication value.
            </remarks> 
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnFileProgress">
            <summary>
            Occurs when archive operation with a file updates a progress indication value.
            </summary>
            <remarks>
            Write an OnFileProgress event handler to display progress of the current operation or to cancel it. OnFileProgress event is triggered by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> when current archive operation with a file updates a progress indication value.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmOverwrite">
            <summary>
            Occurs before application will overwrite existing file.
            </summary>
            <remarks>
            Write a OnConfirmOverwrite event handler to perform some specific actions before overwriting file or to cancel it. OnConfirmOverwrite event can be triggered by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> before overwriting existing file if <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/>.Overwrite = <see cref="T:ComponentAce.Compression.Archiver.OverwriteMode"/>.Prompt.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmProcessFile">
            <summary>
            Occurs before archive group operations.
            </summary>
            <remarks>
            Write an OnConfirmProcessFile event handler to perform some specific actions before executing archive operation or to cancel it. OnConfirmProcessFile event can be triggered by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> before executing operation on the current file.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnAfterOpen">
            <summary>
            Occurs after an application completes opening the archive file.
            </summary>
            <remarks>
            Write an AfterOpen event handler to take specific action immediately after an application <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">opens</see> the archive file.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnPassword">
            <summary>
            Occurs when application needs password for the encrypted file.
            </summary>
            <remarks>
            Write an OnPassword event handler to perform query password for the encrypted file being <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles">extracted</see> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles">tested</see>.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure">
            <summary>
            Occurs in case of failure of the current operation.
            </summary>
            <remarks>
            Write an OnProcessFileFailure event handler to perform some specific actions when archive operation fails. OnProcessFileFailure event is triggered by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> if any file error occurs in the listed methods. If you will not specify event handler for OnProcessFileFailure any error will raise an exception.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestBlankVolume">
            <summary>
            Occurs when next volume should be inserted while writing a multi-volume archive.
            </summary>
            <remarks>
            Write an OnRequestBlankVolume event handler to perform asking the user for inserting a blank volume. Also you can override default file name for the new volume. Use cancel parameter to abort current operation.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestFirstVolume">
            <summary>
            Occurs when first volume should be inserted while extracting or testing a multi-volume archive.
            </summary>
            <remarks>
            Write an OnRequestFirstVolume event handler to perform asking the user for inserting a first volume of the multi-volume archive. 
            See also <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestLastVolume"/> and <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestMiddleVolume"/> events. 
            Also you can override default file name for this volume. Use <paramref name="cancel"/> parameter to abort current operation.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestLastVolume">
            <summary>
            Occurs when last volume should be inserted while extracting or testing a multi-volume archive.
            </summary>
            <remarks>
            Write an OnRequestLastVolume event handler to perform asking the user for inserting a last volume of the multi-volume archive. 
            See also <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestFirstVolume"/> and <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestMiddleVolume"/> events.
            Also you can override default file name for this volume. Use <paramref name="cancel"/> parameter to abort current operation.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestMiddleVolume">
            <summary>
            Occurs when middle volume should be inserted while extracting or testing a multi-volume archive.
            </summary>
            <remarks>
            Write an OnRequestMiddleVolume event handler to perform asking the user for inserting a middle volume of the multi-volume archive. 
            See also <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestFirstVolume"/> and <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestLastVolume"/> events.
            <paramref name="volumeNumber"/> specifies a number of the volume that should be inserted. 
            Also you can override default file name for this volume. Use <paramref name="cancel"/> parameter  to abort current operation. 
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnDiskFull">
            <summary>
            Occurs when current volume for multi-disk spanned archive is full.
            </summary>
            <remarks>
            Write an OnDiskFull event handler to ask user to insert disk with sufficient free space for writing a multi-disk spanned archive.
            Also you can override default file name for this volume using <paramref name="volumeFileName"/>. Use <paramref name="cancel"/> parameter to abort current operation. 
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessVolumeFailure">
            <summary>
            Occurs in case of failure of the current operation.
            </summary>
            <remarks>
            Write an OnProcessVolumeFailure event handler to perform some specific actions when archive operation fails. OnProcessVolumeFailure event is triggered by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> if any file error occurs in the listed methods. If you will not specify event handler for OnProcessVolumeFailure any error will raise an exception.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnStoreFile">
            <summary>
            Occurs when file is being stored into the archive.
            </summary>
            <remarks>
            Write an OnStoreFile event handler to override default file name or change its attributes before storing this file into the archive. The event is fired when <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/> is called.
            </remarks>
        </member>
        <member name="E:ComponentAce.Compression.Archiver.BaseArchiver.OnExtractFile">
            <summary>
            Occurs when file is being extracted from archive.
            </summary>
            <remarks>
            Write an OnExtractFile event handler to override default file name or change its attributes before extracting.
            The event is fired when ExtractFiles is called.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Size">
            <summary>
            Indicates the size in bytes of the opened archive file.
            </summary>
            <remarks>
            The archive file must be opened before you can use this property. If the archive does not exist, create it using the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive"/> method. Archive file is specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property.
            <para> This property is read-only.</para>
            </remarks> 
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.FileCount">
            <summary>
            Indicates the number of files in the archive file.
            </summary>
            <remarks>
            Read FileCount at runtime to determine number of files within an archive file. The archive file must be opened before you can use this property. If the archive does not exist, create it using the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive"/> method. Archive file is specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property.
            <para>This property is read-only.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Exists">
            <summary>
            Indicates whether the archive file exists.
            </summary>
            <remarks>
            Read Exists at runtime to determine whether an archive file exists. If the archive does not exist, create it using the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive"/> method. Archive file is specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property.
            <Para>This property is read-only.</Para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.InUpdate">
            <summary>
            Indicates if an archive file is being updated.
            </summary>
            <remarks>
            Use InUpdate property to determine if the archive file is being updated. Call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.EndUpdate"/> if you need to force transaction system to complete current operation immediately.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Active">
             <summary>
             Specifies whether or not an archive file is open.
             </summary>
             <remarks>Use Active to determine if archive file is opened or to open it. When Active is <b>false</b>, the archive is closed. When Active is <b>true</b>, archive file management is available.
             <para>Setting Active to <b>true</b>: </para>
             <li> Opens archive specified by the <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property</li>
             <li>Triggers the AfterOpen event handler if one is defined for this component.</li>
             <para>If an error occurs while opening the archive exception will be raised and archive file will be closed.</para>
             <para>An application must set Active to <b>false</b> before creating new archive by calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive(System.IO.FileMode)"/> with Create mode.</para>
             <para>Calling the OpenArchive method sets Active to <b>true</b>; calling the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.CloseArchive"/> method sets Active to <b>false</b>.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Comment">
            <summary>
            Specifies the comment of the archive file.
            </summary>
            <remarks>Use this property to set or get the comment of archive file.
            <para>To set comment for each file in archive use <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ChangeFilesComment(System.String,System.String)"/> method.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.EncryptionAlgorithm">
            <summary>
            Specifies the algorithm to use to encrypt archive items.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.OpenCorruptedArchives">
            <summary>
            Specifies whether the corrupted archives can be opened.
            </summary>
            <remarks>
            OpenCorruptedArchives specifies whether to allow opening corrupted archives.
            <para>When this property is <b>false</b>, an <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestLastVolume"/> event will be triggered when corrupted archive is being opened, otherwise the corrupted archive is opened.</para>
            </remarks>
            
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.ExtractCorruptedFiles">
            <summary>
            Specifies whether the partially corrupted files can be extracted from damaged archive. 
            </summary>
            <remarks>
            ExtractCorruptedFiles specifies whether to allow extracting partially corrupted files from damaged archive file. When this property is <b>false</b>, an exception is raised when corrupted file is being extracted, otherwise the file is extracted without error messages. 
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.CompressionMethod">
            <summary>
            Specifies the compression algorithm to use to compress archive items.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.CompressionLevel">
            <summary>
            Specifies the compression level used for archive updating (None, Fastest, Normal, Max).
            </summary>
            <remarks>
            This property determines compression level for adding, moving or updating files. If you need only to store files, set CompressionLevel to None. 
            <para>Set CompressionLevel to desired value before adding, moving or updating files.</para>
            <para> The CompressionLevel and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.CompressionMode"/> properties influence each other. Setting one automatically determines value for the other.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.CompressionMode">
            <summary>
            Specifies the compression level used for archive updating (from 0 to 9).
            </summary>
            <remarks>
            This property determines compression level for <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles">adding</see>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles">moving</see> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles">updating</see> files. The correct values are integer numbers in range 0-9. Maximum value of CompressionMode corresponds to slow compression and best compression rate. The zero value means that files will not be compressed. If you need only to store files, set CompressionMode to 0. 
            <para>Set CompressionMode to desired value before adding, moving or updating files.</para>
            <para>The CompressionMode and <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.CompressionLevel"/> properties influence each other. Setting one automatically determines value for the other. Use CompressionMode for finer control of compression level.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Password">
            <summary>
            Specifies the password for files stored within the archive.
            </summary>
            <remarks>
            Set this property before <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles">adding</see>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles">moving</see>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles">updating</see>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles">extracting</see> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles">testing</see> encrypted files.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName">
            <summary>
            Specifies the archive file name.
            </summary>
            <remarks>
            Use FileName to specify the archive file before calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive"/> procedure.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.BaseDir">
            <summary>
            Specifies default path for archive operations.
            </summary>
            <remarks>
            When files are extracted from archive with <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> all files and directories will be extracted to path specified by BaseDir. Also <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/> and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> will use BaseDir as a default path to external files.
            <para>When files are being tested <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.TempDir"/> is used to temporarily extract files.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.TempDir">
            <summary>
            Specifies a temporary directory to use during archiving operations.
            </summary>
            <remarks>
            TempDir is used by ZipForge to store temporary files created by archive updating operations or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/> method.
            <para>If this property is the empty string, the system's temporary directory will be used.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.SpanningMode">
            <summary>
            Describes how the archive file will be stored on disk.
            </summary>
            <remarks>
            SpanningMode determines how the archive file will be stored on disk: as a single file, as multiple files or it will be stored on  removable disks. <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.SpanningOptions"/> property determines how the archive file will be splitted or spanned.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.SpanningOptions">
            <summary>
            Specifies how the archive file will be splitted or spanned.
            </summary>
            <remarks>
            SpanningOptions property determines how the archive file will be splitted or spanned.
            </remarks>          
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.SFXStub">
            <summary>
            Specifies the file name of the executable stub.
            </summary>
            <remarks>
            Use SFXStub to specify the executable stub before creating self-extracting (SFX) archive by OpenArchive(FileMode.Create) or by calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MakeSFX(System.String)"/>. If SFXStub is not set or set to not existing file when the <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MakeSFX(System.String)"/> method is called, then an exception will be raised.
            <para>If you need to create multi-disk spanned or splitted self-extractable archive you should set SFXStub and call <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive(System.IO.FileMode)"/> with Create mode. Do not use MakeSFX for spanned or splitted archives.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Options">
            <summary>
            Specifies the options for archiving operations.
            </summary>
            <remarks>
            Specify necessary <see cref="T:ComponentAce.Compression.Archiver.ArchiverOptions">Options</see> for archiving operations.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks">
            <summary>
            Specifies files or wildcards for archiver operations.
            </summary>
            <remarks>
            FileMasks are used for overloaded versions without parameters of <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/> methods to select certain files for these operations. This property should contain list of directories and file names including wildcard characters. For example, "C:\\TEST\\*.*" specifies all files in the C:\TEST directory.
            <para>FileMasks property specifies files that should be included into the operation, excluding files specified by <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/>. If you need to store certain files without compression use <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.NoCompressionMasks"/> property.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks">
            <summary>
            Specifies files to be excluded from archive operations.
            </summary>
            <remarks>
            ExclusionMasks are used for overloaded versions without parameters of <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/> methods to exclude certain files for these operations. This property should contain list of excluded directories and file names including wildcard characters. For example, 'C:\TEST\*.*' specifies all files in the C:\TEST directory.
            <para>Three types of exclusion masks can be specified:
            <list type="number">
            <item>
            <description>A mask for the whole BaseDir and all its sub-folders.</description>
            </item>
            <item>
            <description>A mask for the BaseDir only.</description>
            </item>
            <item>
            <description>A mask for an exact full path.</description>
            </item>
            </list>
            </para>
            <para>For example:
            <list type="number">
            <item>
            <description>*.txt  - exclude *.txt in the BaseDir and its sub-folders</description>
            </item>
            <item>
            <description>\*.txt - exclude *.txt files in the BaseDir only</description>
            </item>
            <item>
            <description>C:\The\Full\Path\*.txt - exclude the *.txt files only in the C:\The\Full\Path folder.</description>
            </item>
            </list>
            </para>
            <para><see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> property specifies files that should be included into the operation, excluding files specified by ExclusionMasks. If you need to store certain files without compression use <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.NoCompressionMasks"/> property.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.NoCompressionMasks">
            <summary>
            Specifies masks for files that will be stored without compression.
            </summary>
            <remarks>
            NoCompressionMasks are used for overloaded versions without parameters of <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/> methods to store certain files without compression. This property should contain list of excluded directories and file names including wildcard characters. For example, "C:\\TEST\\*.*" specifies all files in the 'C:\TEST' directory.
            <para><see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileMasks"/> property specifies files that should be included into the operation, excluding files specified by <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.ExclusionMasks"/>.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.InMemory">
            <summary>
            Indicates if an archive file is stored in memory.
            </summary>
            <remarks>
            Indicates whether the current archive file is stored in memory (RAM).
            Set this property to <b>true</b> when you want to <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">create</see> a new or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.OpenArchive">open</see> an existing archive file in memory. If you set it to <b>false</b> file will be opened or created on disk, with the name defined by <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.FileName"/> property.
                Setting InMemory to <b>false</b> when archive file is opened will cause writing the content of the archive file to disk. Set this property to <b>true</b> when you need to load content of the archive file into memory.
                <para> It is not recommended to set InMemory to <b>true</b> with large archive files. ZipForge.NET includes transaction system that optimizes the speed of archives updating.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.BaseArchiver.Current">
            <summary>
            Gets the current <see cref="T:ComponentAce.Compression.Archiver.ArchiveItem"/> from the central directory.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.GetEnumerator"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveNext"/>
            <seealso cref="M:ComponentAce.Compression.Archiver.BaseArchiver.Reset"/>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnOverallProgressDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnOverallProgress"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="progress">Indicates progress for the current group operation in percents.</param>
            <param name="timeElapsed">Indicates time elapsed from the beginning of the operation</param>
            <param name="timeLeft">Indicates time left for the operation to be finished</param>
            <param name="operation">Indicates current archive operation.</param>
            <param name="progressPhase">Indicates the progress <see cref="T:ComponentAce.Compression.Archiver.ProgressPhase">phase</see> of the operation.</param>
            <param name="cancel">Cancel determines if current group operation should be cancelled. Set Cancel to <b>true</b> if you want to cancel executing of the current group operation. Default value for Cancel is <b>false</b>.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnFileProgressDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnFileProgress"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="fileName">Indicates current file name.</param>
            <param name="progress">Indicates progress for the current group operation in percents.</param>
            <param name="timeElapsed">Indicates time elapsed from the beginning of the operation</param>
            <param name="timeLeft">Indicates time left for the operation to be finished</param>
            <param name="operation">Indicates current archive operation.</param>
            <param name="progressPhase">Indicates the progress <see cref="T:ComponentAce.Compression.Archiver.ProgressPhase">phase</see> of the operation.</param>
            <param name="cancel">Cancel determines if current operation on the current file should be cancelled. Set cancel parameter to <b>true</b> if you want to cancel executing of the current operation on the file. Default value for Cancel is <b>false</b>.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmOverwriteDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmOverwrite"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="sourceFileName">Indicates the name of the file that will overwrite existing file.</param>
            <param name="destFileName">Indicates the name of the file being overwritten. Set destFileName if you want to save this file with different name instead of overwriting existing file.</param>
            <param name="confirm">Confirm determines if file will be overwritten. Set confirm to <b>false</b> if you want to cancel overwriting existing file. Default value for confirm is <b>true</b>.</param>
            <param name="cancel">Cancel determines if the current operation should be cancelled. Set cancel to <b>true</b> to cancel the current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmProcessFileDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmProcessFile"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="fileName">Indicates current file name.</param>
            <param name="operation">Indicates current archive operation.</param>
            <param name="confirm">Confirm determines if current operation on the current file will be executed. Set Confirm to <b>false</b> if you want to cancel executing of the current operation on the file. Default value for Confirm is <b>true</b>.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnAfterOpenDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnAfterOpen"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="fileName">Indicates current file name.</param>
            <param name="operation">Indicates current archive operation.</param>
            <param name="confirm">Confirm determines if current operation on the current file will be executed. Set Confirm to <b>false</b> if you want to cancel executing of the current operation on the file. Default value for Confirm is <b>true</b>.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnPasswordDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnPassword"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="fileName">Indicates current file name.</param>
            <param name="newPassword">NewPassword determines new password that will be used for extracting or testing of the encrypted file.</param>
            <param name="skipFile">SkipFile determines if file will be skipped. Set SkipFile to <b>true</b> if you want to skip this file. Default value for SkipFile is <b>false</b>.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailureDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessFileFailure"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="fileName">Indicates current file name.</param>
            <param name="operation">Indicates current archive operation.</param>        
            <param name="errorCode"> Indicates common type of the error. See the <see cref="T:ComponentAce.Compression.Archiver.ErrorCode"/> topic for details on error types.</param>
            <param name="errorMessage"> Indicates error message text.</param>
            <param name="action">Specifies whether the operation with the file should be retried, aborted or the error is to be ignored to process the next file.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestBlankVolumeDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestBlankVolume"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="volumeNumber">Specifies a number of the volume that should be inserted.</param>
            <param name="volumeFileName">Specifies default file name for this volume. You can override default file name.</param>
            <param name="cancel">Use cancel parameter to abort current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestFirstVolumeDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestFirstVolume"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="volumeFileName">Specifies default file name for this volume. You can override default file name.</param>
            <param name="cancel">Use cancel parameter to abort current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestLastVolumeDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestLastVolume"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="volumeFileName">Specifies default file name for this volume. You can override default file name.</param>
            <param name="cancel">Use cancel parameter to abort current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestMiddleVolumeDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestMiddleVolume"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="volumeNumber">Specifies a number of the volume that should be inserted.</param>
            <param name="volumeFileName">Specifies default file name for this volume. You can override default file name.</param>
            <param name="cancel">Use cancel parameter to abort current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnDiskFullDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnDiskFull"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="volumeNumber">Specifies a number of the volume.</param>
            <param name="volumeFileName">Specifies default file name for this volume. You can override default file name.</param>
            <param name="cancel">Use cancel parameter to abort current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessVolumeFailureDelegate">
            <summary>The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnProcessVolumeFailure"/> event.</summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="operation">Indicates current archive operation.</param>
            <param name="volumeNumber">Specifies a number of the volume.</param>
            <param name="volumeFileName">Specifies default file name for this volume. You can override default file name.</param>
            <param name="cancel">Use cancel parameter to abort current operation.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnStoreFileDelegate">
            <summary>
            The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnStoreFile"/> event.
            </summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="item">Specifies the archive item being added to the archive.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseArchiver.OnExtractFileDelegate">
            <summary>
            The delegate to handle the <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnExtractFile"/> event.
            </summary>
            <param name="sender">The Sender is the object whose event handler is called.</param>
            <param name="item">Specifies the archive item being extracted from the archive.</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Compression">
            <summary>
            Compression Class.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.CompressionLevel">
            <summary>
            Specifies the compression level used for archive updating.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionLevel.None">
            <summary>
            There is no compression.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionLevel.Fastest">
            <summary>
            The fastest compression level and low compression rate.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionLevel.Normal">
            <summary>
            Normal compression level. Slower compression and better compression rate than Fastest.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionLevel.Max">
            <summary>
            Slow compression and maximum compression rate.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ProcessOperation">
            <summary>
            Specifies type of an operation being performed over an archive item.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Add">
            <summary>Adds the item to the archive.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Move">
            <summary>Moves the item into the archive.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Delete">
            <summary>Deletes the item from the archive.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Update">
            <summary>Updates the item in the archive.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Extract">
            <summary>Extracts an item from the archive.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Test">
            <summary>Tests an archive item.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.Rename">
            <summary>Rename an archive item.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.ChangeAttr">
            <summary>Changes attributes of an archive item.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProcessOperation.ChangeComment">
            <summary>Changes comments of an archive item.</summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ProgressPhase">
            <summary>
            Specifies a phase of the current archive operation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProgressPhase.Start">
            <summary>
            This value corresponds to the end phase of the operation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProgressPhase.Process">
            <summary>
            This value corresponds to the middle phase of the operation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ProgressPhase.End">
            <summary>
            This value corresponds to the start phase of the operation.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.FailureAction">
            <summary>
            Specifies an action taken on error.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.FailureAction.Retry">
            <summary>Try again.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.FailureAction.Ignore">
            <summary>Ignore error and continue.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.FailureAction.Abort">
            <summary>Abort action.</summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.OverwriteMode">
            <summary>
            Specifies behavior when extracting over already existing files.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.OverwriteMode.Prompt">
            <summary>
            <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnConfirmOverwrite"></see> event will be triggered each time before overwriting existing file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.OverwriteMode.Always">
            <summary>
            All existing files will be replaced with extracted files.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.OverwriteMode.Never">
            <summary>
            Files will not be replaced.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.OverwriteMode.IfNewer">
            <summary>
            Older versions of files will be replaced with extracted newer files.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.OverwriteMode.IfOlder">
            <summary>
            Newer versions of files will be replaced with extracted older files.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ArchiveItem">
            <summary>
            Describes parameters of the file stored within the archive file.
            </summary>
            <remarks>
            ArchiveItem value indicates parameters of the file found by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)">FindFirst</see> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)">FindNext</see>.
            <para>Do not modify Handle field of this record. It is used by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)">FindFirst</see> and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindNext(ComponentAce.Compression.Archiver.ArchiveItem@)">FindNext</see> methods.</para>
            ByVladimir
            </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.fileName">
            <summary>
            Name of the file stored within the archive.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.SrcFileName">
            <summary>
            The name of the file to add to the archive.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.storedPath">
            <summary>
            Path to this file inside the archive. 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.CompressedSize">
            <summary>
            Size in bytes of the compressed file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.UncompressedSize">
            <summary>
            Size in bytes of the uncompressed file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.CompressionRate">
            <summary>
            Indicates compression rate for this file. 
            </summary>
            <remarks>
            CompressionRate = (1 - CompressedSize / UncompressedSize) * 100.0
            </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.Encrypted">
            <summary>
            Indicates if file is encrypted with <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Password"/>.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.encryptionAlgorithm">
            <summary>
            Algorithm used to encrypt archive item.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.CRC">
            <summary>
            CRC32 check sum of the compressed file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.ExternalFileAttributes">
            <summary>
            Indicates external file attributes. 
            </summary>
            <remarks>
            If Options.SetAttributes is set to <b>true</b> then <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/> will set these attributes to the extracted file.
            </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ArchiveItem.Comment">
            <summary>
            Comment of the file stored in the archive.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ArchiveItem.Reset">
            <summary>
            Resets archive item to default empty state (no associated file).
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ArchiveItem.#ctor">
            <overloads>Creates a new instance of the <see cref="T:ComponentAce.Compression.Archiver.ArchiveItem"/> class.</overloads>
            <summary>
            Creates a new, empty instance of the <see cref="T:ComponentAce.Compression.Archiver.ArchiveItem"/> class which does not refer to any file.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ArchiveItem.#ctor(System.String)">
            <summary>
            Creates a new instance of the ArchiveItem class and fills its properties with the properties of the file with the name '<paramref name="fileName"/>'.
            </summary>
            <param name="fileName">A full name of the file to create archive item from.</param>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.FileName">
            <summary>
            Gets/Sets name of the file stored within the archive.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.LastWriteTime">
            <summary>
            Gets date and time when archive item was last written to (last modified time).
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.FileCreationDateTime">
            <summary>
            Gets/Sets file creation date and time.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.FileLastAccessDateTime">
            <summary>
            Gets/Sets file last access date and time.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.FileModificationDateTime">
            <summary>
            Gets/Sets file modification date and time.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.FullName">
            <summary>
            Gets full path name of the archive item.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.StoredPath">
            <summary>
            Gets/Sets the path to the file which is stored in the archive. 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiveItem.EncryptionAlgorithm">
            <summary>
            Gets/Sets algorithm used to encrypt/decrypt archive item.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.StorePathMode">
             <summary>
             Specifies how path information will be stored for the file or directory within the archive file.
             </summary>
            <remarks>
             StorePathMode value defines how path information will be stored for the file or directory within the archive file. If you need to store all files and directories without path you should use NoPath value. For example, AddFiles("C:\TEST\test.txt") adds file test.txt to the archive. If you will extract it by ExtractFiles("*.*") and BaseDir will be "C:\", file test.txt will be extracted to "C\":, not to "C:\TEST". 
             <para>If you need to store path relative to certain directory you should set BaseDir before adding file to archive and set Options.StorePath to Relative. In this case if you will set BaseDir to "C:\" and call AddFiles("C:\TEST\test.txt") the file test.txt will be stored as "TEST\test.txt" within the archive. If you will extract it by ExtractFiles("*.*") it will be extracted to "C:\TEST\test.txt", not to "C:\" as in previous example.</para>
             <para>If you need to store full path you should set Options.StorePath to FullPath. Previous example will store test.txt within the archive file as "\TEST\test.txt" and file will be extracted to disk specified by BaseDir.</para>
             <para>If you need to store absolute path with drive you should set Options.StorePath to FullPathWithDrive. Previous AddFiles example will store test.txt within the archive file as "C:\TEST\test.txt" and the file will be extracted to disk using stored absolute path regardless of BaseDir.</para>
             </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.StorePathMode.NoPath">
            <summary>
            No path information stored.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.StorePathMode.RelativePath">
            <summary>
            Path information stored relatively BaseDir.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.StorePathMode.FullPath">
            <summary>
            Path information stored relatively disk specified by BaseDir.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.StorePathMode.FullPathWithDrive">
            <summary>
            Absolute path with drive letter stored. Non-standard extension of PKZip format.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Zip64Mode">
             <summary>
             Specifies a zip file format. 
             </summary>
             <remarks>
             Use Zip64Mode for creating Zip64 archives. Thus you can create archive files > 4Gb and add files > 4 Gb to the archive. 
             Set Zip64Mode to zmAlways to add files in Zip64 format. Use zmAuto for auto-detection of the archive format depending on sizes of the files being added. zmDisabled is a default value for creating archives in normal Zip format, compatible with most of archivers.
            <para>Zip64 format is not supported by some archivers. ZipForge uses the same format as PKZip. Nevertheless we do not guarantee that it is compatible with other programs.</para>
            </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64Mode.Disabled">
            <summary>
            A default value for creating archives in normal Zip format.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64Mode.Auto">
            <summary>
            Auto-detection of the archive format depending on sizes of the files being added.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64Mode.Always">
            <summary>
            Always create archives in Zip64 format.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.SpanningMode">
            <summary>
            Specifies how the archive file will be stored on disk.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.SpanningMode.None">
            <summary>
            The archive will be stored as a single file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.SpanningMode.Spanning">
            <summary>
            The archive file will be stored on removable disks.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.SpanningMode.Splitting">
            <summary>
            The archive will be stored as multiple  files.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.VolumeSize">
            <summary>
            Specifies the size of the multi-spanning archive volumes.
            </summary>
            <remarks>
            VolumeSize value specifies the size of each multi-disk archive volume. 
            Set <see cref="T:ComponentAce.Compression.Archiver.SpanningOptions"/>.VolumeSize to AutoDetect for automatic detection of the volume blockSizeToDecompress (default value). 
            You can also use Custom value and specify the volume blockSizeToDecompress by setting SpanningOptions.CustomVolumeSize.
            </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.AutoDetect">
            <summary>
            Autodetect of the volume size.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Custom">
            <summary>
            Custom volume size.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk1_44MB">
            <summary>
            Volume size is 1.44 Mb (3.5" floppy disk).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk100MB">
            <summary>
            Volume size is 100 Mb (IOMEGA disk).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk200MB">
            <summary>
            Volume size is 200 Mb (MO disk).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk600MB">
            <summary>
            Volume size is 600 Mb (MO disk).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk650MB">
            <summary>
            Volume size is 650 Mb (74 Min. compact disk).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk700MB">
            <summary>
            Volume size is 700 Mb (80 Min. compact disk).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.VolumeSize.Disk4700MB">
            <summary>
            Volume size is 4700 Mb (DVD disk). 
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.EncryptionAlgorithm">
            <summary>
            Specifies encryption algorithms which can be used to encrypt/decrypt archives.
            </summary>
            <remarks>
            <para>Attention: <a target="_blank" href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Strong AES Encryption</a> 
            is available only in ZipForge.NET Professional edition.</para>
            ByVladimir
            </remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.EncryptionAlgorithm.Aes128">
            <summary>
            (Professional edition only) Strong AES Encryption with 128-bit keys.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.EncryptionAlgorithm.Aes192">
            <summary>
            (Professional edition only) Strong AES Encryption with 192-bit keys.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.EncryptionAlgorithm.Aes256">
            <summary>
            (Professional edition only) Strong AES Encryption with 256-bit keys.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.EncryptionAlgorithm.None">
            <summary>
            No encryption
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.EncryptionAlgorithm.PkzipClassic">
            <summary>
            Standard PKZIP encryption, considered weak by today's standards.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.SpanningOptions">
            <summary>
            Describes how the archive file will be splitted or spanned.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.SpanningOptions.#ctor">
            <summary>
            Creates a new instance of the SpanningOptions class with default parameters.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.SpanningOptions.Assign(System.Object)">
            <summary>
            Allows to copy all options from another <see cref="T:ComponentAce.Compression.Archiver.SpanningOptions"/> object in one operation.
            </summary>
            <param name="Source">The <see cref="T:ComponentAce.Compression.Archiver.SpanningOptions"/> object to copy settings from.</param>
            <remarks>
            <para>You have to use it because <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.SpanningOptions"/> property is readonly.</para>
            ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.SpanningOptions.AdvancedNaming">
            <summary>
            Determines how the archive volumes will be named. 
            </summary>
            <remarks>
            If AdvancedNaming is set to <b>true</b> then archive volumes will be named like archive_001.zip, archive_002.zip, ... ,archive_999.zip. 
                <para>If AdvancedNaming is set to <b>false</b> and SpanningMode is set to smSpanning then archive volumes will be named like archive.zip on each removable disk.</para>
            <para>If AdvancedNaming is set to <b>false</b> and SpanningMode is set to smSplitting then archive volumes will be named like archive.z01, archive.z02, ... , archive.z99.</para>
            <para>You can also specify custom name for each volume using <see cref="E:ComponentAce.Compression.Archiver.BaseArchiver.OnRequestBlankVolume"/> event handler.</para>
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.SpanningOptions.FirstVolumeSize">
            <summary>
            Specifies the size of first volume in bytes.
            </summary>
            <remarks>
            The FirstVolumeSize specifies the size of first volume, minimum blockSizeToDecompress is 64 Kb. If the FirstVolumeSize is set to 0 the blockSizeToDecompress of the first volume will be the same as other volumes and will be defined by <see cref="P:ComponentAce.Compression.Archiver.SpanningOptions.VolumeSize"/> value.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.SpanningOptions.VolumeSize">
            <summary>
            Specifies the size of the volumes for archive splitting or spanning. 
            </summary>
            <remarks>
            The VolumeSize specifies the size of the volumes for archive splitting or spanning. If the VolumeSize is set to Custom, then <see cref="P:ComponentAce.Compression.Archiver.SpanningOptions.CustomVolumeSize"/> will be used.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.SpanningOptions.CustomVolumeSize">
            <summary>
            Specifies the custom blockSizeToDecompress of the volumes for archive splitting or spanning.
            </summary>
            <remarks>
            The CustomVolumeSize specifies the custom blockSizeToDecompress of the volumes for archive splitting or spanning. This parameter can be used only when <see cref="P:ComponentAce.Compression.Archiver.SpanningOptions.VolumeSize"/> is set to Custom.
            </remarks>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ArchiverOptions">
            <summary>
            Specifies the ZipForge options.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ArchiverOptions.Assign(System.Object)">
            <summary>
            Allows to copy all options from another <see cref="T:ComponentAce.Compression.Archiver.ArchiverOptions"/> object in one operation.
            </summary>
            <param name="Source">The <see cref="T:ComponentAce.Compression.Archiver.ArchiverOptions"/> object to copy settings from.</param>
            <remarks>
            <para>You have to use it because <see cref="P:ComponentAce.Compression.Archiver.BaseArchiver.Options"/> property is readonly.</para>
            ByVladimir</remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ArchiverOptions.#ctor">
             <summary>
            Creates a new instance of the ArchiverOptions class with default parameters.
             </summary>                          
             <remarks>ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.Recurse">
            <summary>
            Specifies if archive operation will search files recursively.
            </summary>
            <remarks>
            Recurse specifies if <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/>, 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> 
            and <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/> methods will search files recursively. 
            This means that if some folder meets search conditions then all files and directories 
            within this folder will be scanned. For example, if you set Recurse to true and call 
            AddFiles("C:\\*.*",FileAttributes.Nornal) all files and folders 
            located on disk C: will be added to the archive.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.StorePath">
            <summary>
            Defines how path information will be stored for the file or directory within the archive file.
            </summary>
            <remarks>
            This option applies to <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> methods.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.ShareMode">
            <summary>
            Specifies how the files being added to the archive will be opened for simultaneous access.
            </summary>
            <remarks>
            Set this option before calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/> or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.Overwrite">
            <summary>
            Specifies whether extracted files will overwrite existing files.
            </summary>
            <remarks>
            Set this option before calling <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>, 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>
            or <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/>.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.CreateDirs">
            <summary>
            Specifies whether to create folders when extracting an archive.
            </summary>
            <remarks>
            Set CreateDirs to <b>true</b> if you need to extract files with creating all necessary folders.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.ReplaceReadOnly">
            <summary>
            Specifies whether to replace read-only files when extracting files from archive.
            </summary>
            <remarks>
            If ReplaceReadOnly set to <b>true</b> it means that all existing read-only files will be replaced with the files being extracted by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.SetAttributes">
            <summary>
            Determines whether attributes stored within the archive will be applied to extracted files.
            </summary>
            <remarks>
            SetAttributes determines whether attributes stored within the archive will be applied to files being extracted by <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.SearchAttr">
            <summary>
            Specifies the special files to include in addition to all normal files.
            </summary>
            <remarks>
            SearchAttr specifies the special files to include in addition to all normal files for 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.FindFirst(ComponentAce.Compression.Archiver.ArchiveItem@)"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.AddFiles"/>, 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.ExtractFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.TestFiles"/>, 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.MoveFiles"/>, <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.UpdateFiles"/> and 
            <see cref="M:ComponentAce.Compression.Archiver.BaseArchiver.DeleteFiles"/> methods variant without parameters.
            </remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverOptions.FlushBuffers">
            <summary>
            Specifies whether the file buffers are flushed after archive file modification and after extracting files from archive.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.DirItemDataDescriptor">
            <summary>
            Represents data descriptor block which is present after file data if the bit-3 of the general purpose bit flags is set.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.Clone">
            <summary>
            Returns a copy of the object
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.LoadDataDescriptor(System.IO.Stream,System.Int64)">
            <summary>
            Loads the current item data descriptor from the stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.SaveDataDescriptor(System.IO.Stream,System.Int64)">
            <summary>
            Saves the current item data descriptor to the stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.LoadExtraFieldsFromStream(System.IO.Stream,System.UInt16)">
            <summary>
            Forces the directory item to read its extra fields from the stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.LoadLocalHeaderExtraFieldsFromStream(System.IO.Stream,System.UInt16)">
            <summary>
            Reads extra fields from item local header.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.GetDataOffset">
            <summary>
            Returns an offset of the compressed file data relative to the item local header position
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirItem.GetExtraFieldsLength(ComponentAce.Compression.Archiver.ExtraFieldsTarget)">
            <summary>
            Gets/Sets the extraLength value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.ExtraFields">
            <summary>
            Gets the ExtraFieldsDataBlock for the current directory item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.NeedDestroyStream">
            <summary>
            If we need to destroy stream
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.StreamPosition">
            <summary>
            Gets/Sets starting position of the diritem in this stream
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.SrcFileName">
            <summary>
            Gets/Sets the source file name used to add/move/update
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.Password">
            <summary>
            Gets/Sets password for encrypting/decrypting directory item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.CompressionMode">
            <summary>
            Gets/Sets the compression mode used for this item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.IsTagged">
            <summary>
            Is the current directory item was tagged for group operations
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.Operation">
            <summary>
            Gets/Sets the operation that should be applied to the current directory item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.Stream">
            <summary>
            Get/Sets source data stream (when there is no file)
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.IsModified">
            <summary>
            If the item was updated or added (that is modified)
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.IsHugeFile">
            <summary>
            If the Zip64 format is used to store this directory item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.Comment">
            <summary>
            Gets/Sets directory item comment
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.EncryptionAlgorithm">
            <summary>
            Gets/Sets the encryption algorithm used to encrypt this directory item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.Signature">
            <summary>
            Gets/Sets the signature value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.VersionMadeBy">
            <summary>
            Gets/Sets the versionMadeBy value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.ExtractVersion">
            <summary>
            Gets/Sets the extractVersion value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.GeneralPurposeFlag">
            <summary>
            Gets/Sets the getPurposeFlag value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.ActualCompressionMethod">
            <summary>
            Gets/Sets the actual compression method (if AES is used the compressionMethod field contains special value)
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.CompressionMethod">
            <summary>
            Gets/Sets the compressionMethod value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.LastModificationTime">
            <summary>
            Gets/Sets the lastModTime value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.LastModificationDate">
            <summary>
            Gets/Sets the lastModDate value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.CRC32">
            <summary>
            Gets/Sets the CRC32 value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.CompressedSize">
            <summary>
            Gets/Sets the compSize value for the Central dir object if the value is less than 0xFFFFFFFF and from the Zip64ExtraField otherwise
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.UncompressedSize">
            <summary>
            Gets/Sets the uncompSize value for the Central dir object if the value is less than 0xFFFFFFFF and from the Zip64ExtraField otherwise
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.NameLength">
            <summary>
            Gets/Sets the nameLength value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.DataDescriptor">
            <summary>
            Gets/Sets the dataDescriptor block for the item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.CommentLength">
            <summary>
            Gets/Sets the commentLength value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.DiskStartNumber">
            <summary>
            Gets/Sets the diskNumberStart value for the Central dir object if the value is less than oxFFFF or from the Zip64ExtrField otherwise
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.InternalAttributes">
            <summary>
            Gets/Sets the internalAttr value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.ExternalAttributes">
            <summary>
            Gets/Sets the externalAttr value for the Central dir object
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.DirItem.RelativeLocalHeaderOffset">
            <summary>
            Gets/Sets the relOffsetLH value for the Central dir object if the value is less than 0xFFFFFFFF or from the Zip64Extra Field otherwise
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirArray.GetDirItemIndexByName(System.String)">
            <summary>
            Checks if the item with the 'name' name exists in the collection
            </summary>
            <returns>The index of the item in the collection if it exists, -1 - otherwise</returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.DirManager.LoadDir">
            <summary>
            Load central directory
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ZipUtil.RemoveEscapeSequences(System.String)">
            <summary>
            Removes \r, \n, \f, \t, \v escape sequences from the string
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.CompressionMethods">
            <summary>
            This class contains available compression algorithms to specify in directory item or local header
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.CompressionMethod">
            <summary>
            Specifies available compression algorithms.
            </summary>
            <remarks>
            <para><b>Attention:</b> Bzip2 and PPMd compression algorithms are available only in Zipforge.NET Professional edition.</para>
            ByVladimir</remarks>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionMethod.None">
            <summary>No compression.</summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionMethod.Deflate">
            <summary>
            Deflate compression algorithm (see <a target="_blank" href="http://en.wikipedia.org/wiki/DEFLATE">Wikipedia article</a> about it).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionMethod.BZIP2">
            <summary>
            (Professional edition only) Bzip2 compression algorithm (see <a target="_blank" href="http://en.wikipedia.org/wiki/Bzip2">Wikipedia article</a> about it).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.CompressionMethod.PPMd">
            <summary>
            (Professional edition only) PPMd compression algorithm (see <a target="_blank" href="http://en.wikipedia.org/wiki/Prediction_by_Partial_Matching">general description</a>,
            and <a target="_blank" href="http://www.compression.ru/ds/">PPMd library home page (russian)</a>.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ErrorCode">
            <summary>
            Contains constants for different error types which can occur during ZipForge operations.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.UnknownError">
            <summary>
            Unknown error.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.IndexOutOfBounds">
            <summary>
            Index was out of bounds. Most likely an attempt to get the non-existent directory item occurred.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidCompressionMode">
            <summary>
            Invalid compression mode was specified.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.UnexpectedNull">
            <summary>
            Some inner object equals null.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidCheckSum">
            <summary>
            Invalid size or check sum of file or unsupported compression format. The error can be caused by the fact that archive data is corrupted.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.BlankFileName">
            <summary>
            File name is blank. You need to specify appropriate file name.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.FileNotFound">
            <summary>
            File was not found.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.ArchiveIsNotOpen">
            <summary>
            Archive is not open. You are attempting to perform some operation which requires the archive to be open. You need to call the ZipForge.Open method before.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.StubNotSpecified">
            <summary>
            SFXStub property is not specified.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotCreateFile">
            <summary>
            Cannot create file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotCreateDir">
            <summary>
            Cannot create directory.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.NotInUpdate">
            <summary>
            Internal error. Update is not started.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotOpenFile">
            <summary>
            Cannot open file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InUpdate">
            <summary>
            Cannot proceed when update is not ended. Preceding EndUpdate call is required.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotDeleteFile">
            <summary>
            Cannot delete file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InMemoryArchiveCanBeCreatedOnly">
            <summary>
            In-memory archive can be created only.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.FileIsInReadonlyMode">
            <summary>
            File is open in read-only mode.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidCompressedSize">
            <summary>
            Invalid compressed size is specified.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidFormat">
            <summary>
            Invalid archive file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotCreateOutputFile">
            <summary>
            Cannot create output file. Probably file is locked by another process.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.ArchiveIsOpen">
            <summary>
            Archive is open. You should close it before performing this operation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.UnableToCreateDirectory">
            <summary>
            Unable to create directory.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.UnableToFindZip64DirEnd">
            <summary>
            Cannot find Zip64 directory end record.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.HugeFileModeIsNotEnabled">
            <summary>
            The file is to large, you have to enable Zip64 mode.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotOpenArchiveFile">
            <summary>
            Cannot open archive file.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotWriteToStream">
            <summary>
            Write to stream error.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CannotFitSFXStubOnVolume">
            <summary>
            Cannot place SFX stub on volume. Volume size limit is too small.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.DamagedArchive">
            <summary>
            Archive is damaged. Open failed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.MakeSFXIsNotAllowed">
            <summary>
            MakeSFX is not allowed for splitted or spanned archives. Set SFXStub before archive creation instead of MakeSFX.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.ArchiveAlreadyHasSFXStub">
            <summary>
            Archive already has SFX stub.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.MultiVolumeArchiveIsNotAllowed">
            <summary>
            Multi-volume archive is not allowed for custom stream.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.SpanningModificationIsNotAllowed">
            <summary>
            Multi-spanned archive is not allowed for modification. Use BeginUpdate/EndUpdate methods to add files several times.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.IncorrectPassword">
            <summary>
            Incorrect password is specified for the encrypted archive.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidVolumeName">
            <summary>
            Invalid volume name.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidUnicodeExtraFieldSignature">
            <summary>
            The unicode extra field signature is incorrect.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.InvalidExtraFieldID">
            <summary>
            The extra field ID value is incorrect. Possibly the archive is damaged.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.NoOnRequestBlankVolumeHandler">
            <summary>
            The OnRequestBlankVolume event handler doesn't exists. You should handle this event to work with spanning archives.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.NoOnRequestFirstVolumeHandler">
            <summary>
            The OnRequestFirstVolume event handler doesn't exists. You should handle this event to work with spanning archives.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.NoOnRequestMiddleVolumeHandler">
            <summary>
            The OnRequestMiddleVolume event handler doesn't exists. You should handle this event to work with spanning archives.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.NoOnRequestLastVolumeHandler">
            <summary>
            The OnRequestLastVolume event handler doesn't exists. You should handle this event to work with spanning archives.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.DiskIsFull">
            <summary>
            The disk is full.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.CompressionEngineIsNotInitialized">
            <summary>
            Compression engine is not initialized.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ErrorCode.UnknownCompressionMethod">
            <summary>
            Unknown compression method.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ArchiverException">
            <summary>
            ArchiverException class allows user to know <see cref="T:ComponentAce.Compression.Archiver.ErrorCode"/> 
            and to get objects related to exception.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ArchiverException.#ctor(System.String,ComponentAce.Compression.Archiver.ErrorCode,System.Object[],System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ComponentAce.Compression.Archiver.ArchiverException"/> class 
            with an additional error code and an array of objects explaining exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="errorCode">The code of the error that caused exception.</param>
            <param name="Args">The array of objects (arguments) explaining exception, if any.</param>
            <param name="innerException">The exception that is the cause of the current exception, if any.</param>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverException.Args">
            <summary>
            Gets/Sets array of objects explaining exception.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ArchiverException.ErrorCode">
            <summary>
            Gets/Sets code of the error that caused exception.
            </summary>
            <remarks>ByVladimir</remarks>
        </member>
        <member name="T:ComponentAce.Compression.Libs.bzip2.BZip2Constants_Fields">
            <summary> Base class for both the compress and decompress classes.
            Holds common arrays, and static data.
            
            </summary>
            <author>  <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            </author>
        </member>
        <member name="T:ComponentAce.Compression.Libs.bzip2.CBZip2InputStream">
            <summary> An input stream that decompresses from the BZip2 format (without the file
            header chars) to be read as any other stream.
            
            </summary>
            <author>  <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            </author>
        </member>
        <member name="T:ComponentAce.Compression.Libs.bzip2.CBZip2OutputStream">
            <summary> An output stream that compresses into the BZip2 format (without the file
            header chars) into another stream.
            
            </summary>
            <author>  <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
            TODO:    Update to BZip2 1.0.1
            </author>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.CBZip2OutputStream.WriteByte(System.Int32)">
            <summary> 
            modified by Oliver Merkel, 010128
            
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.bzip2.CRC">
            <summary> A simple class the hold and calculate the CRC for sanity checking
            of the data.
            
            </summary>
            <author>  <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            </author>
        </member>
        <member name="T:ComponentAce.Compression.Libs.bzip2.SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.bzip2.SupportClass.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.Allocator">
            <summary>
            Allocate a single, large array and then provide sections of this array to callers.  Callers are provided with
            instances of <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/> (which simply contain a single address value, representing a location
            in the large array).
            </summary>
            <remarks>
            Note that in most cases fields are used rather than properties for performance reasons (for example,
            <see cref="F:ComponentAce.Compression.Libs.PPMd.Allocator.AllocatorSize"/> is a field rather than a property).
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.#cctor">
            <summary>
            Initializes static read-only arrays used by the <see cref="T:ComponentAce.Compression.Libs.PPMd.Allocator"/>.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.Initialize">
            <summary>
            Initialize or reset the memory allocator (so that the single, large array can be re-used without destroying
            and re-creating it).
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.Start(System.Int32)">
            <summary>
            Start the allocator (create a single, large array of bytes).
            </summary>
            <remarks>
            Note that .NET will create that array on the large object heap (because it is so large).
            </remarks>
            <param name="allocatorSize"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.Stop">
            <summary>
            Stop the allocator (free the single, large array of bytes).  This can safely be called multiple times (without
            intervening calls to <see cref="M:ComponentAce.Compression.Libs.PPMd.Allocator.Start(System.Int32)"/>).
            </summary>
            <remarks>
            Because the array is on the large object heap it may not be freed immediately.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.GetMemoryUsed">
            <summary>
            Determine how much memory (from the single, large array) is currenly in use.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.AllocateUnits(System.UInt32)">
            <summary>
            Allocate a given number of units from the single, large array.  Each unit is <see cref="F:ComponentAce.Compression.Libs.PPMd.Allocator.UnitSize"/> bytes
            in size.
            </summary>
            <param name="unitCount"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.AllocateContext">
            <summary>
            Allocate enough space for a <see cref="T:ComponentAce.Compression.Libs.PPMd.Model.PpmContext"/> instance in the single, large array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.ExpandUnits(ComponentAce.Compression.Libs.PPMd.Pointer,System.UInt32)">
            <summary>
            Increase the size of an existing allocation (represented by a <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/>).
            </summary>
            <param name="oldPointer"></param>
            <param name="oldUnitCount"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.ShrinkUnits(ComponentAce.Compression.Libs.PPMd.Pointer,System.UInt32,System.UInt32)">
            <summary>
            Decrease the size of an existing allocation (represented by a <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/>).
            </summary>
            <param name="oldPointer"></param>
            <param name="oldUnitCount"></param>
            <param name="newUnitCount"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.FreeUnits(ComponentAce.Compression.Libs.PPMd.Pointer,System.UInt32)">
            <summary>
            Free previously allocated space (the location and amount of space to free must be specified by using
            a <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/> to indicate the location and a number of units to indicate the amount).
            </summary>
            <param name="pointer"></param>
            <param name="unitCount"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Allocator.ExpandText">
            <summary>
            Expand the space allocated (in the single, large array) for the bytes of the data (ie. the "text") that is
            being encoded or decoded.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.Coder">
            <summary>
            A simple range coder.
            </summary>
            <remarks>
            Note that in most cases fields are used rather than properties for performance reasons (for example,
            <see cref="F:ComponentAce.Compression.Libs.PPMd.Coder.Scale"/> is a field rather than a property).
            </remarks>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.MemoryNode">
            <summary>
            A structure containing a single address.  The address represents a location in the <see cref="F:ComponentAce.Compression.Libs.PPMd.MemoryNode.Memory"/>
            array.  That location in the <see cref="F:ComponentAce.Compression.Libs.PPMd.MemoryNode.Memory"/> array contains information itself describing a section
            of the <see cref="F:ComponentAce.Compression.Libs.PPMd.MemoryNode.Memory"/> array (ie. a block of memory).
            </summary>
            <remarks>
            <para>
            This must be a structure rather than a class because several places in the associated code assume that
            <see cref="T:ComponentAce.Compression.Libs.PPMd.MemoryNode"/> is a value type (meaning that assignment creates a completely new copy of
            the instance rather than just copying a reference to the same instance).
            </para>
            <para>
            MemoryNode
                4 Stamp
                4 Next
                4 UnitCount
            </para>
            <para>
            Note that <see cref="F:ComponentAce.Compression.Libs.PPMd.MemoryNode.Address"/> is a field rather than a property for performance reasons.
            </para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:ComponentAce.Compression.Libs.PPMd.MemoryNode"/> structure.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.Link(ComponentAce.Compression.Libs.PPMd.MemoryNode)">
            <summary>
            Link in the provided memory node.
            </summary>
            <param name="memoryNode"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.Unlink">
            <summary>
            Unlink this memory node.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.Insert(ComponentAce.Compression.Libs.PPMd.MemoryNode,System.UInt32)">
            <summary>
            Insert the memory node into the linked list.
            </summary>
            <param name="memoryNode"></param>
            <param name="unitCount"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.Remove">
            <summary>
            Remove this memory node from the linked list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Implicit(ComponentAce.Compression.Libs.PPMd.Pointer)~ComponentAce.Compression.Libs.PPMd.MemoryNode">
            <summary>
            Allow a pointer to be implicitly converted to a memory node.
            </summary>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Addition(ComponentAce.Compression.Libs.PPMd.MemoryNode,System.Int32)">
            <summary>
            Allow pointer-like addition on a memory node.
            </summary>
            <param name="memoryNode"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Addition(ComponentAce.Compression.Libs.PPMd.MemoryNode,System.UInt32)">
            <summary>
            Allow pointer-like addition on a memory node.
            </summary>
            <param name="memoryNode"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Subtraction(ComponentAce.Compression.Libs.PPMd.MemoryNode,System.Int32)">
            <summary>
            Allow pointer-like subtraction on a memory node.
            </summary>
            <param name="memoryNode"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Subtraction(ComponentAce.Compression.Libs.PPMd.MemoryNode,System.UInt32)">
            <summary>
            Allow pointer-like subtraction on a memory node.
            </summary>
            <param name="memoryNode"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Equality(ComponentAce.Compression.Libs.PPMd.MemoryNode,ComponentAce.Compression.Libs.PPMd.MemoryNode)">
            <summary>
            Compare two memory nodes.
            </summary>
            <param name="memoryNode1"></param>
            <param name="memoryNode2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.op_Inequality(ComponentAce.Compression.Libs.PPMd.MemoryNode,ComponentAce.Compression.Libs.PPMd.MemoryNode)">
            <summary>
            Compare two memory nodes.
            </summary>
            <param name="memoryNode1"></param>
            <param name="memoryNode2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>true if obj and this instance are the same type and represent the same value; otherwise, false.</returns>
            <param name="obj">Another object to compare to.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.MemoryNode.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.MemoryNode.Stamp">
            <summary>
            Gets or sets the stamp.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.MemoryNode.Next">
            <summary>
            Gets or sets the next memory node.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.MemoryNode.UnitCount">
            <summary>
            Gets or sets the unit count.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.MemoryNode.Available">
            <summary>
            Gets whether there is a next memory node available.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.Model">
            <summary>
            The model.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.Encode(System.IO.Stream,System.IO.Stream,System.Int32,ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod)">
            <summary>
            Encode (ie. compress) a given source stream, writing the encoded result to the target stream.
            </summary>
            <param name="target"></param>
            <param name="source"></param>
            <param name="modelOrder"></param>
            <param name="modelRestorationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.Decode(System.IO.Stream,System.IO.Stream,System.Int32,ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod)">
            <summary>
            Dencode (ie. decompress) a given source stream, writing the decoded result to the target stream.
            </summary>
            <param name="target"></param>
            <param name="source"></param>
            <param name="modelOrder"></param>
            <param name="modelRestorationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.StartModel(System.Int32,ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod)">
            <summary>
            Initialise the model (unless the model order is set to 1 in which case the model should be cleared so that
            the statistics are carried over, allowing "solid" mode compression).
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.Model.PpmContext">
            <summary>
            The structure which represents the current PPM context.  This is 12 bytes in size.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:ComponentAce.Compression.Libs.PPMd.Model.PpmContext"/> structure.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_Implicit(ComponentAce.Compression.Libs.PPMd.Pointer)~ComponentAce.Compression.Libs.PPMd.Model.PpmContext">
            <summary>
            Allow a pointer to be implicitly converted to a PPM context.
            </summary>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_Addition(ComponentAce.Compression.Libs.PPMd.Model.PpmContext,System.Int32)">
            <summary>
            Allow pointer-like addition on a PPM context.
            </summary>
            <param name="context"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_Subtraction(ComponentAce.Compression.Libs.PPMd.Model.PpmContext,System.Int32)">
            <summary>
            Allow pointer-like subtraction on a PPM context.
            </summary>
            <param name="context"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_LessThanOrEqual(ComponentAce.Compression.Libs.PPMd.Model.PpmContext,ComponentAce.Compression.Libs.PPMd.Model.PpmContext)">
            <summary>
            Compare two PPM contexts.
            </summary>
            <param name="context1"></param>
            <param name="context2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_GreaterThanOrEqual(ComponentAce.Compression.Libs.PPMd.Model.PpmContext,ComponentAce.Compression.Libs.PPMd.Model.PpmContext)">
            <summary>
            Compare two PPM contexts.
            </summary>
            <param name="context1"></param>
            <param name="context2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_Equality(ComponentAce.Compression.Libs.PPMd.Model.PpmContext,ComponentAce.Compression.Libs.PPMd.Model.PpmContext)">
            <summary>
            Compare two PPM contexts.
            </summary>
            <param name="context1"></param>
            <param name="context2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.op_Inequality(ComponentAce.Compression.Libs.PPMd.Model.PpmContext,ComponentAce.Compression.Libs.PPMd.Model.PpmContext)">
            <summary>
            Compare two PPM contexts.
            </summary>
            <param name="context1"></param>
            <param name="context2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>true if obj and this instance are the same type and represent the same value; otherwise, false.</returns>
            <param name="obj">Another object to compare to.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.NumberStatistics">
            <summary>
            Gets or sets the number statistics.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.Flags">
            <summary>
            Gets or sets the flags.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.SummaryFrequency">
            <summary>
            Gets or sets the summary frequency.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.Statistics">
            <summary>
            Gets or sets the statistics.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.Suffix">
            <summary>
            Gets or sets the suffix.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstState">
            <summary>
            The first PPM state associated with the PPM context.
            </summary>
            <remarks>
            <para>
            The first PPM state overlaps this PPM context instance (the SummaryFrequency and Statistics members
            of PpmContext use 6 bytes and so can therefore fit into the space used by the Symbol, Frequency and
            Successor members of PpmState, since they also add up to 6 bytes).
            </para>
            <para>
            PpmContext (SummaryFrequency and Statistics use 6 bytes)
                1 NumberStatistics
                1 Flags
                2 SummaryFrequency
                4 Statistics (pointer to PpmState)
                4 Suffix (pointer to PpmContext)
            </para>
            <para>
            PpmState (total of 6 bytes)
                1 Symbol
                1 Frequency
                4 Successor (pointer to PpmContext)
            </para>
            </remarks>
            <returns></returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstStateSymbol">
            <summary>
            Gets or sets the symbol of the first PPM state.  This is provided for convenience.  The same
            information can be obtained using the Symbol property on the PPM state provided by the
            <see cref="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstState"/> property.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstStateFrequency">
            <summary>
            Gets or sets the frequency of the first PPM state.  This is provided for convenience.  The same
            information can be obtained using the Frequency property on the PPM state provided by the
            <see cref="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstState"/> property.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstStateSuccessor">
            <summary>
            Gets or sets the successor of the first PPM state.  This is provided for convenience.  The same
            information can be obtained using the Successor property on the PPM state provided by the
            <see cref="P:ComponentAce.Compression.Libs.PPMd.Model.PpmContext.FirstState"/> property.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod">
            <summary>
            The method used to adjust the model when the memory limit is reached.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod.Restart">
            <summary>
            Restart the model from scratch (this is the default).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod.CutOff">
            <summary>
            Cut off the model (nearly twice as slow).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.ModelRestorationMethod.Freeze">
            <summary>
            Freeze the context tree (in some cases may result in poor compression).
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.Options">
            <summary>
            Command line options that modify the manner in which the command line action is performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.Options.None">
            <summary>
            No options specified.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.Options.Checksum">
            <summary>
            Calculate the CRC (ie. checksum) for files.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.Options.Delete">
            <summary>
            Delete files (if encoding then delete the file after it has been compressed into the archive; otherwise,
            if decoding then delete the archive after all files have been decompressed from the archive).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.Options.Quiet">
            <summary>
            Do not prompt for files to be deleted or overwritten.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.PPMd.Options.Solid">
            <summary>
            Compress files based on the content of other files (typically produces smaller archives).
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.Pointer">
            <summary>
            A structure containing a single address representing a position in the <see cref="F:ComponentAce.Compression.Libs.PPMd.Pointer.Memory"/> array.  This
            is intended to mimic the behaviour of a pointer in C/C++.
            </summary>
            <remarks>
            <para>
            This must be a structure rather than a class because several places in the associated code assume that
            <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/> is a value type (meaning that assignment creates a completely new copy of the
            instance rather than just copying a reference to the same instance).
            </para>
            <para>
            Note that <see cref="F:ComponentAce.Compression.Libs.PPMd.Pointer.Address"/> is a field rather than a property for performance reasons.
            </para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/> structure.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Implicit(ComponentAce.Compression.Libs.PPMd.MemoryNode)~ComponentAce.Compression.Libs.PPMd.Pointer">
            <summary>
            Allow a <see cref="T:ComponentAce.Compression.Libs.PPMd.MemoryNode"/> to be implicitly converted to a <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/>.
            </summary>
            <param name="memoryNode"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Implicit(ComponentAce.Compression.Libs.PPMd.Model.PpmContext)~ComponentAce.Compression.Libs.PPMd.Pointer">
            <summary>
            Allow a <see cref="T:ComponentAce.Compression.Libs.PPMd.Model.PpmContext"/> to be implicitly converted to a <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/>.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Implicit(ComponentAce.Compression.Libs.PPMd.PpmState)~ComponentAce.Compression.Libs.PPMd.Pointer">
            <summary>
            Allow a <see cref="T:ComponentAce.Compression.Libs.PPMd.PpmState"/> to be implicitly converted to a <see cref="T:ComponentAce.Compression.Libs.PPMd.Pointer"/>.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Addition(ComponentAce.Compression.Libs.PPMd.Pointer,System.Int32)">
            <summary>
            Increase the address of a pointer by the given number of bytes.
            </summary>
            <param name="pointer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Addition(ComponentAce.Compression.Libs.PPMd.Pointer,System.UInt32)">
            <summary>
            Increase the address of a pointer by the given number of bytes.
            </summary>
            <param name="pointer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Increment(ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Increment the address of a pointer.
            </summary>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Subtraction(ComponentAce.Compression.Libs.PPMd.Pointer,System.Int32)">
            <summary>
            Decrease the address of a pointer by the given number of bytes.
            </summary>
            <param name="pointer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Subtraction(ComponentAce.Compression.Libs.PPMd.Pointer,System.UInt32)">
            <summary>
            Decrease the address of a pointer by the given number of bytes.
            </summary>
            <param name="pointer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Decrement(ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Decrement the address of a pointer.
            </summary>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Subtraction(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Subtract two pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns>The number of bytes between the two pointers.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_LessThan(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Compare pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_LessThanOrEqual(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Compare two pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_GreaterThan(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Compare two pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_GreaterThanOrEqual(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Compare two pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Equality(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Compare two pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.op_Inequality(ComponentAce.Compression.Libs.PPMd.Pointer,ComponentAce.Compression.Libs.PPMd.Pointer)">
            <summary>
            Compare two pointers.
            </summary>
            <param name="pointer1"></param>
            <param name="pointer2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>true if obj and this instance are the same type and represent the same value; otherwise, false.</returns>
            <param name="obj">Another object to compare to.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.Pointer.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.Pointer.Item(System.Int32)">
            <summary>
            Gets or sets the byte at the given <paramref name="offset"/>.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.PpmState">
            <summary>
            PPM state.
            </summary>
            <remarks>
            <para>
            This must be a structure rather than a class because several places in the associated code assume that
            <see cref="T:ComponentAce.Compression.Libs.PPMd.PpmState"/> is a value type (meaning that assignment creates a completely new copy of the
            instance rather than just copying a reference to the same instance).
            </para>
            <para>
            Note that <see cref="F:ComponentAce.Compression.Libs.PPMd.PpmState.Address"/> is a field rather than a property for performance reasons.
            </para>
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:ComponentAce.Compression.Libs.PPMd.PpmState"/> structure.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Implicit(ComponentAce.Compression.Libs.PPMd.Pointer)~ComponentAce.Compression.Libs.PPMd.PpmState">
            <summary>
            Allow a pointer to be implicitly converted to a PPM state.
            </summary>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Addition(ComponentAce.Compression.Libs.PPMd.PpmState,System.Int32)">
            <summary>
            Allow pointer-like addition on a PPM state.
            </summary>
            <param name="state"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Increment(ComponentAce.Compression.Libs.PPMd.PpmState)">
            <summary>
            Allow pointer-like incrementing on a PPM state.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Subtraction(ComponentAce.Compression.Libs.PPMd.PpmState,System.Int32)">
            <summary>
            Allow pointer-like subtraction on a PPM state.
            </summary>
            <param name="state"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Decrement(ComponentAce.Compression.Libs.PPMd.PpmState)">
            <summary>
            Allow pointer-like decrementing on a PPM state.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_LessThanOrEqual(ComponentAce.Compression.Libs.PPMd.PpmState,ComponentAce.Compression.Libs.PPMd.PpmState)">
            <summary>
            Compare two PPM states.
            </summary>
            <param name="state1"></param>
            <param name="state2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_GreaterThanOrEqual(ComponentAce.Compression.Libs.PPMd.PpmState,ComponentAce.Compression.Libs.PPMd.PpmState)">
            <summary>
            Compare two PPM states.
            </summary>
            <param name="state1"></param>
            <param name="state2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Equality(ComponentAce.Compression.Libs.PPMd.PpmState,ComponentAce.Compression.Libs.PPMd.PpmState)">
            <summary>
            Compare two PPM states.
            </summary>
            <param name="state1"></param>
            <param name="state2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.op_Inequality(ComponentAce.Compression.Libs.PPMd.PpmState,ComponentAce.Compression.Libs.PPMd.PpmState)">
            <summary>
            Compare two PPM states.
            </summary>
            <param name="state1"></param>
            <param name="state2"></param>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>true if obj and this instance are the same type and represent the same value; otherwise, false.</returns>
            <param name="obj">Another object to compare to.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.PPMd.PpmState.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.PpmState.Symbol">
            <summary>
            Gets or sets the symbol.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.PpmState.Frequency">
            <summary>
            Gets or sets the frequency.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.PpmState.Successor">
            <summary>
            Gets or sets the successor.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.PPMd.PpmState.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:ComponentAce.Compression.Libs.PPMd.PpmState"/> at the <paramref name="offset"/> relative to this
            <see cref="T:ComponentAce.Compression.Libs.PPMd.PpmState"/>.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.PPMd.See2Context">
            <summary>
            SEE2 (secondary escape estimation) contexts for PPM contexts with masked symbols.
            </summary>
            <remarks>
            <para>
            This must be a class rather than a structure because MakeEscapeFrequency returns a See2Context
            instance from the see2Contexts array.  The caller (for example, EncodeSymbol2) then updates the
            returned See2Context instance and expects the updates to be reflected in the see2Contexts array.
            This would not happen if this were a structure.
            </para>
            <remarks>
            Note that in most cases fields are used rather than properties for performance reasons (for example,
            <see cref="F:ComponentAce.Compression.Libs.PPMd.See2Context.Shift"/> is a field rather than a property).
            </remarks>
            </remarks>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.FileUtils">
            <summary>
            Used in ZipForge and ZipForge.CF for compatibility with CF
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.CompressionDirection">
            <summary>
            Enumeration representing the direction of the compression (compress, decompress)
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseCompressor">
            <summary>
            Abstract class representing compression algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseCompressor.Init(ComponentAce.Compression.Archiver.CompressionDirection,System.Byte)">
            <summary>
            Initializes the compressor to compress or decompress files
            </summary>
            <param name="direction">Specifies whether the data is compressed or decompressed</param>
            <param name="compressionMode">Specifices the compression mode, from 0 to 9</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseCompressor.CompressBlock(System.UInt32,System.Int64,System.Boolean,System.Byte[],System.Int64@,System.Byte[]@)">
            <summary>
            Compresses block of data
            </summary>
            <param name="blockSize">The size of the block used for compression</param>
            <param name="currentBlockSize">The size of the current block (can be less than blockSize if remaining data size is less than buffer size)</param>
            <param name="compressedDataSize">The size of the compressed data</param>
            <param name="isFinalBlock">True if the the current block is a final one</param>
            <param name="sourceBuffer">A buffer to compress</param>
            <param name="resultBuffer">Result buffer</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseCompressor.DecompressBlock(System.Int32,System.Boolean,System.Byte[],System.Int64@)">
            <summary>
            Decompresses block of data. Fires OnOut
            </summary>
            <param name="currentBlockSize">The size of the block used for decompression</param>
            <param name="sourceBuffer">A buffer to decompress</param>
            <param name="isFinalBlock">True if the the current block is a final one</param>
            <param name="decompressedDataSize">Total size of the decompressed data</param>        
            <returns>True - if operation succeeded and false otherwise</returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.BaseCompressor.Close">
            <summary>
            Performs finalization operations
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BaseCompressor.DecompressedBufferReady">
            <summary>
            Fired when output buffer is full or compression finished
            </summary>
            <param name="buffer">Decompressed buffer</param>
            <param name="outBytes">Actual decompressed bytes</param>
            <param name="stopDecompression">Assign True to stop decompression process</param>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.StoreCompressor">
            <summary>
            Represents compressor which just store file in archive (without compression)
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.DeflateCompressor">
            <summary>
            Deflate compression algorithm
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.BZIP2Compressor">
            <summary>
            BZIP2 compression algorithm
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.PPMdCompressor">
            <summary>
            PPMd compression algorithm
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ExtraFieldIDs">
            <summary>
            Some IDs of the zip files extra fields 
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ExtraFieldsTarget">
            <summary>
            A number of values to indicate where we want to store/read extra fields: local header or central directory. The value is needed for Zip64ExtraField since the header contains only 2 of 4 fields
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ExtraFieldData">
            <summary>
            Represents an extra field record
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldData.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.UnicodeExtraFieldData">
            <summary>
            Represents Xceed unicode file name extra field record
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.UnicodeExtraFieldData.FileName">
            <summary>
            Gets/Sets the value of the unicode file name
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.UnicodeExtraFieldData.FileNameLength">
            <summary>
            Gets the length of the filename
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.Zip64ExtraFieldData">
            <summary>
            Represents the zip64 extra fields record
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.fieldID">
            <summary>
            Zip 64 extra field ID
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.uncompSize">
            <summary>
            Uncompressed file size
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.compSize">
            <summary>
            Compressed file size
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.relOffsetLH">
            <summary>
            Local header offset
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.diskNumberStart">
            <summary>
            start disk number
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.LoadFromStream(System.IO.Stream,ComponentAce.Compression.Archiver.DirItem)">
            <summary>
            The static method creates a new Zip64ExtraFieldData using the data read from the source stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.UpdateBaseClassFields">
            <summary>
            Updates fields of the base class
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.GetFieldDataSize(ComponentAce.Compression.Archiver.ExtraFieldsTarget)">
            <summary>
            Returns the value of the dataSize for the Zip64 extra field
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.GetFieldData(ComponentAce.Compression.Archiver.ExtraFieldsTarget)">
            <summary>
            returns a byte array of the current extra field data
            </summary>
            <returns></returns>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.UncompressedFileSize">
            <summary>
            Gets/Sets the uncompressed file size value
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.CompressedFileSize">
            <summary>
            Gets/Sets the compressed file size value
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.LocalHeaderOffset">
            <summary>
            Gets/Sets the offset of the file local header
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.Zip64ExtraFieldData.StartDiskNumber">
            <summary>
            Gets/Sets the start disk number
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.AESExtraFieldData">
            <summary>
            Represents AES encryption extra fields
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.AESExtraFieldData.VersionNumber">
            <summary>
            Gets/Sets the value of the AES encryption version number
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.AESExtraFieldData.KeyLengthBits">
            <summary>
            Gets/Sets the value of AES encryption key length
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.AESExtraFieldData.CompressionMethod">
            <summary>
            Gets/Sets the value of the actual compression method
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock">
            <summary>
            Represents a block of extra fields records of the file in zip archive
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.extraFieldsArray">
            <summary>
            A collection of extra fields
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.GetBytesLength(ComponentAce.Compression.Archiver.ExtraFieldsTarget)">
            <summary>
            Returns total length in bytes of extra fields block
            </summary>		
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.WriteToStream(System.IO.Stream,System.Int64,ComponentAce.Compression.Archiver.ExtraFieldsTarget)">
            <summary>
            Writes the complete extra fields block to the source stream
            </summary>
            <param name="source">The stream to write to.</param>
            <param name="offset">The offset in the <paramref name="source"/> stream.</param>
            <param name="target">Specifies whether we write data for the local header or central dir</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.GetBytes(ComponentAce.Compression.Archiver.ExtraFieldsTarget)">
            <summary>
            Returns a byte array of extra fields data
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.GetExtraFieldByID(System.UInt16)">
            <summary>
            Returnes extra field data block with specified header Id 
            </summary>
            <param name="headerID">Extra field header ID</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.AddExtraField(ComponentAce.Compression.Archiver.ExtraFieldData,ComponentAce.Compression.Archiver.DirItem)">
            <summary>
            Add the extraField extra fieldto the collection
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.RemoveExtraField(ComponentAce.Compression.Archiver.ExtraFieldData)">
            <summary>
            Removes the given extra field from the collection
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.RemoveExtraFieldByID(System.UInt16)">
            <summary>
            Removes an extra field with the given ID from the collection
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.GetExtraFieldsArray">
            <summary>
            Returns an array of extra fields
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.Clone">
            <summary>
            Implementation of the ICloneable interface
            </summary>
            <returns></returns>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.Reset">
            <summary>
            Clears the extra fields collection
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.LoadFromStream(System.IO.Stream,System.UInt16,ComponentAce.Compression.Archiver.DirItem)">
            <summary>
            This static method creates an array of extra fields by loading them from the stream and adds the array to the "item" directory item
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.Count">
            <summary>
            Returns a number of extra field records in a collection
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.Item(System.Int32)">
            <summary>
            Indexer allows to get an extra field by its index
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Archiver.ExtraFieldsDataBlock.Zip64ExtraField">
            <summary>
            Returns a reference to the Zip64 extra field if it exists or null 
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Archiver.InputPasswordForm">
            <summary>
            Summary description for InputPasswordForm.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.InputPasswordForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.InputPasswordForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.InputPasswordForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Archiver.ConfirmOverwriteDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ConfirmOverwriteDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ComponentAce.Compression.Archiver.ConfirmOverwriteDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.ZipForge.ZipForge">
            <summary>
            Manages ZIP archives. 
            </summary>
            <remarks>
            Use ZipForge to create, open, close or update ZIP archives. 
            This component provides all necessary properties, methods and events for handling ZIP files.
            </remarks>
        </member>
        <member name="M:ComponentAce.Compression.ZipForge.ZipForge.#ctor">
            <summary>
            Initializes a new instance of the ZipForge class with the default parameters.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.ZipForge.ZipForge.Zip64Mode">
            <summary>
            Specifies whether to use Zip64 format to create archives over 4GB. 
            </summary>
            <remarks>
            Use Zip64Mode for creating Zip64 archives. Thus you can create archive files > 4Gb and add files > 4 Gb to the archive. Set Zip64Mode to zmAlways to add files in Zip64 format. Use zmAuto for auto-detection of the archive format depending on sizes of the files being added. zmDisabled is a default value for creating archives in normal Zip format, compatible with most of archivers.
            <para>Zip64 format is not supported by some archivers. ZipForge.NET uses the same format as PKZip. Nevertheless we do not guarantee that it is compatible with other programs.</para> 
            </remarks> 
        </member>
        <member name="P:ComponentAce.Compression.ZipForge.ZipForge.UnicodeFilenames">
            <summary>
            Specifies whether unicode file names are saved in addition to filenames in standard OEM encoding.
            </summary>	    	    
        </member>
        <member name="P:ComponentAce.Compression.ZipForge.ZipForge.StoreNTFSTimeStamps">
            <summary>
            Specifies whether file modification, last access and creation times are saved.
            </summary>	    	    
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Adler32">
            <summary>
            This class represents adler32 checksum algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Adler32.GetAdler32Checksum(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            This static method returns adler32 checksum of the buffer data
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Deflate">
            <summary>
            Implementation of the Deflate compression algorithm.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.MAX_MEM_LEVEL">
            <summary>
            Maximum memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Z_DEFAULT_COMPRESSION">
            <summary>
            Defalult compression method
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.DEF_MEM_LEVEL">
            <summary>
            Default memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.NeedMore">
            <summary>
            block not completed, need more input or more output
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.BlockDone">
            <summary>
            Block internalFlush performed
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.FinishStarted">
            <summary>
            Finish started, need only more output at next deflate
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.FinishDone">
            <summary>
            finish done, accept no more input or output
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.PRESET_DICT">
            <summary>
            preset dictionary flag in zlib header
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Z_DEFLATED">
            <summary>
            The deflate compression method
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Buf_size">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REP_3_6">
            <summary>
            repeat previous bit length 3-6 times (2 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REPZ_3_10">
            <summary>
            repeat a zero length 3-10 times  (3 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REPZ_11_138">
            <summary>
            repeat a zero length 11-138 times  (7 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.config_table">
            <summary>
            Deflate class congiration table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strm">
            <summary>
            Pointer back to this zlib stream
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.status">
            <summary>
            As the name implies
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_buf">
            <summary>
            Output still pending
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_buf_size">
            <summary>
            Size of Pending_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_out">
            <summary>
            Next pending byte to output to the stream
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending">
            <summary>
            Number of bytes in the pending buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.noheader">
            <summary>
            suppress zlib header and adler32
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.data_type">
            <summary>
            // UNKNOWN, BINARY or ASCII
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.method">
            <summary>
            STORED (for zip only) or DEFLATED
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_flush">
            <summary>
            Value of internalFlush parameter for previous deflate call
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_size">
            <summary>
            LZ77 Window size (32K by default)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_bits">
            <summary>
            log2(w_size)  (8..16)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_mask">
            <summary>
            w_size - 1
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.window">
            <summary>
            Sliding Window. Input bytes are ReadPos into the second half of the Window,
            and move to the first half later to keep a dictionary of at least wSize
            bytes. With this organization, matches are limited to a distance of
            wSize-MAX_MATCH bytes, but this ensures that IO is always
            performed with a length multiple of the block size. Also, it limits
            the Window size to 64K, which is quite useful on MSDOS.
            To do: use the user input buffer as sliding Window.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.window_size">
            <summary>
            Actual size of Window: 2*wSize, except when the user input buffer is directly used as sliding Window.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev">
            <summary>
            Link to older string with same hash index. To limit the size of this
            array to 64K, this link is maintained only for the last 32K strings.
            An index in this array is thus a Window index modulo 32K.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.head">
            <summary>
            Heads of the hash chains or NIL.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.ins_h">
            <summary>
            hash index of string to be inserted
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_size">
            <summary>
            number of elements in hash table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_bits">
            <summary>
            log2(hash_size)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_mask">
            <summary>
            hash_size-1
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_shift">
            <summary>
            Number of bits by which ins_h must be shifted at each input
            step. It must be such that after MIN_MATCH steps, the oldest
            byte no longer takes part in the hash key, that is:
            hash_shift * MIN_MATCH >= hash_bits
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.block_start">
            <summary>
            Window position at the beginning of the current output block. Gets negative when the Window is moved backwards.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_length">
            <summary>
            length of best match
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev_match">
            <summary>
            previous match
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_available">
            <summary>
            set if previous match exists
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strstart">
            <summary>
            start of string to insert
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_start">
            <summary>
            start of matching string
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.lookahead">
            <summary>
            number of valid bytes ahead in Window
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev_length">
            <summary>
            Length of the best match at previous step. Matches not greater than this
            are discarded. This is used in the lazy match evaluation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.max_chain_length">
            <summary>
            To speed up deflation, hash chains are never searched beyond this
            length.  A higher limit improves compression ratio but degrades the speed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.max_lazy_match">
            <summary>
            Attempt to find a better match only when the current match is strictly
            smaller than this value. This mechanism is used only for compression
            levels >= 4.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate._level">
            <summary>
            compression level (1..9)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strategy">
            <summary>
            favor or force Huffman coding
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.good_match">
            <summary>
            Use a faster search when the previous match is longer than this
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.nice_match">
            <summary>
            Stop searching when current match exceeds this
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.dyn_ltree">
            <summary>
            literal and length tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.dyn_dtree">
            <summary>
            distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_tree">
            <summary>
             Huffman tree for bit lengths
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.l_desc">
            <summary>
            Desc for literal tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.d_desc">
            <summary>
            desc for distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_desc">
            <summary>
            desc for bit length tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_count">
            <summary>
            number of codes at each bit length for an optimal tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap">
            <summary>
            heap used to build the Huffman trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap_len">
            <summary>
            number of elements in the heap
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap_max">
            <summary>
            element of largest frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.depth">
            <summary>
            Depth of each subtree used as tie breaker for trees of equal frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.l_buf">
            <summary>
            index for literals or lengths
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.lit_bufsize">
            <summary>
             Size of match buffer for literals/lengths.  There are 4 reasons for
             limiting lit_bufsize to 64K:
               - frequencies can be kept in 16 bit counters
               - if compression is not successful for the first block, all input
                 data is still in the Window so we can still emit a stored block even
                 when input comes from standard input.  (This can also be done for
                 all blocks if lit_bufsize is not greater than 32K.)
               - if compression is not successful for a file smaller than 64K, we can
                 even emit a stored file instead of a stored block (saving 5 bytes).
                 This is applicable only for zip (not gzip or zlib).
               - creating new Huffman trees less frequently may not provide fast
                 adaptation to changes in the input data statistics. (Take for
                 example a binary file with poorly compressible code followed by
                 a highly compressible string table.) Smaller buffer sizes give
                 fast adaptation but have of course the overhead of transmitting
                 trees more frequently.
               - I can't count above 4
            </summary> 
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_lit">
            <summary>
            running index in l_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.d_buf">
            <summary>
            index of pendig_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.opt_len">
            <summary>
            bit length of current block with optimal trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.static_len">
            <summary>
            bit length of current block with static trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.matches">
            <summary>
            number of string matches in current block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_eob_len">
            <summary>
            bit length of EOB code for last block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bi_buf">
            <summary>
            Output buffer. bits are inserted starting at the bottom (least
            significant bits).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bi_valid">
            <summary>
            Number of valid bits in bi_buf.  All bits above the last valid bit
            are always zero.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.lm_init">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.tr_init">
            <summary>
            Initialize the tree data structures for a new zlib stream.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.init_block">
            <summary>
            Initializes block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.pqdownheap(System.Int16[],System.Int32)">
            <summary>
             Restore the heap property by moving down the tree starting at node k,
             exchanging a node with the smallest of its two sons if necessary, stopping
             when the heap property is re-established (each father smaller than its
             two sons).
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.scan_tree(System.Int16[],System.Int32)">
            <summary>
             Scan a literal or distance tree to determine the frequencies of the codes
             in the bit length tree.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.build_bl_tree">
            <summary>
             Construct the Huffman tree for the bit lengths and return the index in
             bl_order of the last bit length code to send.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.send_all_trees(System.Int32,System.Int32,System.Int32)">
            <summary>
             Send the header for a block using dynamic Huffman trees: the counts, the
             lengths of the bit length codes, the literal tree and the distance tree.
             IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.send_tree(System.Int16[],System.Int32)">
            <summary>
             Send a literal or distance tree in compressed form, using the codes in
             bl_tree.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.put_byte(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Output a byte on the stream.
             IN assertion: there is enough room in Pending_buf.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.put_byte(System.Byte)">
            <summary>
            Adds a byte to the buffer
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_align">
            <summary>
             Send one empty static block to give enough lookahead for inflate.
             This takes 10 bits, of which 7 may remain in the bit buffer.
             The current inflate code requires 9 bits of lookahead. If the
             last two codes for the previous block (real code plus EOB) were coded
             on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
             the last real code. In this case we send two empty static blocks instead
             of one. (There are no problems if the previous block is stored or fixed.)
             To simplify the code, we assume the worst case of last real code encoded
             on one bit only.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_tally(System.Int32,System.Int32)">
            <summary>
            Save the match info and tally the frequency counts. Return true if
            the current block must be flushed.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.compress_block(System.Int16[],System.Int16[])">
            <summary>
             Send the block data compressed using the given Huffman trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.set_data_type">
            <summary>
            Set the data type to ASCII or BINARY, using a crude approximation:
            binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.
            IN assertion: the fields freq of dyn_ltree are set and the total of all
            frequencies does not exceed 64K (to fit in an int on 16 bit machines).
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.bi_flush">
            <summary>
            Flush the bit buffer, keeping at most 7 bits in it.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.bi_windup">
            <summary>
            Flush the bit buffer and align the output on a byte boundary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.copy_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copy a stored block, storing first the length and its
            one's complement if requested.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.flush_block_only(System.Boolean)">
            <summary>
            Flushes block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_stored(System.Int32)">
            <summary>
            Copy without compression as much as possible from the input stream, return
            the current block state.
            This function does not insert new strings in the dictionary since
            uncompressible data is probably not useful. This function is used
            only for the level=0 compression option.
            NOTE: this function should be optimized to avoid extra copying from
            Window to Pending_buf.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_stored_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Send a stored block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_flush_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determine the best encoding for the current block: dynamic trees, static
            trees or store, and output the encoded block to the zip file.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.fill_window">
            <summary>
             Fill the Window when the lookahead becomes insufficient.
             Updates strstart and lookahead.
            
             IN assertion: lookahead less than MIN_LOOKAHEAD
             OUT assertions: strstart less than or equal to window_size-MIN_LOOKAHEAD
                At least one byte has been ReadPos, or _avail_in == 0; reads are
                performed for at least two bytes (required for the zip translate_eol
                option -- not supported here).
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_fast(System.Int32)">
            <summary>
             Compress as much as possible from the input stream, return the current
             block state.
             This function does not perform lazy evaluation of matches and inserts
             new strings in the dictionary only for unmatched strings or for short
             matches. It is used only for the fast compression options.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_slow(System.Int32)">
            <summary>
             Same as above, but achieves better compression. We use a lazy
             evaluation for matches: a match is finally adopted only if there is
             no better match at the next Window position.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.longest_match(System.Int32)">
            <summary>
            Finds the longest matching data part
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,System.Int32)">
            <summary>
            Deflate algorithm initialization
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <param name="bits">Window bits</param>
            <returns>A result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Initializes deflate algorithm
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <returns>Operation result result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateInit2(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,System.Int32,System.Int32,System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Deflate algorithm initialization
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <param name="method">Compression method</param>
            <param name="windowBits">Window bits</param>
            <param name="memLevel">Memory level</param>
            <param name="strategy">Compression strategy</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateReset(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Resets the current state of deflate object
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateEnd">
            <summary>
            Finish compression with deflate algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateParams(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Sets deflate algorithm parameters
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateSetDictionary(ComponentAce.Compression.Libs.ZLib.ZStream,System.Byte[],System.Int32)">
            <summary>
            Sets deflate dictionary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate(ComponentAce.Compression.Libs.ZLib.ZStream,ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            Performs data compression with the deflate algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.#cctor">
            <summary>
            Static constructor initializes config_table
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.level">
            <summary>
            Compression level
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending">
            <summary>
            Number of bytes in the pending buffer
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending_buf">
            <summary>
            Output still pending
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending_out">
            <summary>
            Next pending byte to output to the stream
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.NoHeader">
            <summary>
            suppress zlib header and adler32
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Deflate.Config">
            <summary>
            Deflate algorithm configuration parameters class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.good_length">
            <summary>
            reduce lazy search above this match length
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.max_lazy">
            <summary>
            do not perform lazy search above this match length
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.nice_length">
            <summary>
            quit search above this match length
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.Config.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor which initializes class inner fields
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.mode">
            <summary>
            current inflate_block mode 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.left">
            <summary>
            if STORED, bytes left to copy 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.table">
            <summary>
            table lengths (14 bits) 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.index">
            <summary>
            index into blens (or border) 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.blens">
            <summary>
            bit lengths of codes 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bb">
            <summary>
            bit length tree depth 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.tb">
            <summary>
            bit length decoding tree 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.codes">
            <summary>
            if CODES, current state 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.last">
            <summary>
            true if this block is the last block 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bitk">
            <summary>
            bits in bit buffer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bitb">
            <summary>
            bit buffer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.hufts">
            <summary>
            single malloc for tree space 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.window">
            <summary>
            sliding Window 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.end">
            <summary>
            one byte after sliding Window 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.read">
            <summary>
            Window ReadPos pointer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.write">
            <summary>
            Window WritePos pointer 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.needCheck">
            <summary>
            need check
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.check">
            <summary>
            check on output 
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.reset(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int64[])">
            <summary>
            Resets this InfBlocks class instance
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.proc(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Block processing functions
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.free(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Frees inner buffers
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.set_dictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets dictionary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.sync_point">
            <summary>
             Returns true if inflate is currently at the End of a block generated
             by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.inflate_flush(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            copy as much as possible from the sliding Window to the output area
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.Window">
            <summary>
            sliding window 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.End">
            <summary>
            one byte after sliding Window 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.ReadPos">
            <summary>
            Window ReadPos pointer 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.WritePos">
            <summary>
            Window WritePos pointer 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.BitK">
            <summary>
            bits in bit buffer 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.BitB">
            <summary>
            bit buffer 
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InflateCodesMode">
            <summary>
            Inflate codes mode
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InfCodes">
            <summary>
            This class is used by the InfBlocks class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.mode">
            <summary>
            current inflate_codes mode
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.count">
            <summary>
            length
            </summary>        
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.tree">
            <summary>
            pointer into tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.tree_index">
            <summary>
            current index of the tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.need">
            <summary>
            
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.lbits">
            <summary>
            ltree bits decoded per branch
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dbits">
            <summary>
            dtree bits decoded per branch
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.ltree">
            <summary>
            literal/length/eob tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.ltree_index">
            <summary>
            literal/length/eob tree index
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dtree">
            <summary>
            distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dtree_index">
            <summary>
            distance tree index
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Constructor which takes literal, distance trees, corresponding bites decoded for branches, corresponding indexes and a ZStream object 
            </summary>        
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Constructor which takes literal, distance trees, corresponding bites decoded for branches and a ZStream object 
            </summary>   
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.proc(ComponentAce.Compression.Libs.ZLib.InfBlocks,ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Block processing method
            </summary>
            <param name="s">An instance of the InfBlocks class</param>
            <param name="z">A ZStream object</param>
            <param name="r">A result code</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.free(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Frees allocated resources
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.inflate_fast(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,ComponentAce.Compression.Libs.ZLib.InfBlocks,ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Fast inflate procedure. Called with number of bytes left to WritePos in Window at least 258
            (the maximum string length) and number of input bytes available
            at least ten.  The ten bytes are six bytes for the longest length/
            distance pair plus four bytes for overloading the bit buffer.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InflateMode">
            <summary>
            This enumeration contains modes of inflate processing
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.METHOD">
            <summary>
            waiting for method byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.FLAG">
            <summary>
            waiting for flag byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT4">
            <summary>
            four dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT3">
            <summary>
            three dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT2">
            <summary>
            two dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT1">
            <summary>
            one dictionary check byte to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT0">
            <summary>
            waiting for inflateSetDictionary
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.BLOCKS">
            <summary>
            decompressing blocks
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK4">
            <summary>
            four check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK3">
            <summary>
            three check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK2">
            <summary>
            two check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK1">
            <summary>
            one check byte to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DONE">
            <summary>
            finished check, done
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.BAD">
            <summary>
            got an error--stay here
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.mode">
            <summary>
            current inflate mode
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.method">
            <summary>
            if FLAGS, method byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.was">
            <summary>
            computed check value
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.need">
            <summary>
            stream check value
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.marker">
            <summary>
            if BAD, inflateSync's marker bytes count
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.nowrap">
            <summary>
            flag for no wrapper
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.wbits">
            <summary>
            log2(Window size)  (8..15, defaults to 15)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.blocks">
            <summary>
            current inflate_blocks state
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateReset(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Resets the Inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <returns>A result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateEnd(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Finishes the inflate algorithm processing
            </summary>
            <param name="z">A ZStream object</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Initializes the inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <param name="windowBits">Window size</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflate(ComponentAce.Compression.Libs.ZLib.ZStream,ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            Runs inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <param name="flush">Flush strategy</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSetDictionary(ComponentAce.Compression.Libs.ZLib.ZStream,System.Byte[],System.Int32)">
            <summary>
            Sets dictionary for the inflate operation
            </summary>
            <param name="z">A ZStream object</param>
            <param name="dictionary">An array of byte - dictionary</param>
            <param name="dictLength">Dictionary length</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSync(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Inflate synchronization
            </summary>
            <param name="z">A ZStream object</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSyncPoint(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
             Returns true if inflate is currently at the End of a block generated
             by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
             implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
             but removes the length bytes of the resulting empty stored block. When
             decompressing, PPP checks that at the End of input packet, inflate is
             waiting for these length bytes.
             </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InfTreeUtil">
            <summary>
            Contains utility information for the InfTree class
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.huft_build(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Given a list of code lengths and a maximum table size, make a set of
            tables to decode that set of codes.  
            </summary>
            <returns>Return (int)ZLibResultCode.Z_OK on success, (int)ZLibResultCode.Z_DATA_ERROR if the given code set is incomplete (the tables are still built in this case), (int)ZLibResultCode.Z_DATA_ERROR if the input is invalid (an over-subscribed set of lengths), or (int)ZLibResultCode.Z_DATA_ERROR if not enough memory.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_bits(System.Int32[],System.Int32[],System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Build trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_dynamic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Builds dynamic trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_fixed(System.Int32[],System.Int32[],System.Int32[][],System.Int32[][],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Build fixed trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.StaticTree.MAX_BL_BITS">
            <summary>
             Bit length codes must not exceed MAX_BL_BITS bits
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Tree">
            <summary>
            This class represents a tree and is used in the Deflate class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.dyn_tree">
            <summary>
            The dynamic tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.max_code">
            <summary>
            Largest code with non zero frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.stat_desc">
            <summary>
            the corresponding static tree
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.d_code(System.Int32)">
            <summary>
            Mapping from a distance to a distance code. dist is the distance - 1 and
            must not have side effects. _dist_code[256] and _dist_code[257] are never
            used.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.gen_bitlen(ComponentAce.Compression.Libs.ZLib.Deflate)">
            <summary>
             Compute the optimal bit lengths for a tree and update the total bit length
             for the current block.
             IN assertion: the fields freq and dad are set, heap[heap_max] and
                above are the tree nodes sorted by increasing frequency.
             OUT assertions: the field count is set to the optimal bit length, the
                 array bl_count contains the frequencies for each bit length.
                 The length opt_len is updated; static_len is also updated if stree is
                 not null.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.build_tree(ComponentAce.Compression.Libs.ZLib.Deflate)">
            <summary>
             Construct one Huffman tree and assigns the code bit strings and lengths.
             Update the total bit length for the current block.
             IN assertion: the field freq is set for all tree elements.
             OUT assertions: the fields count and code are set to the optimal bit length
                 and corresponding code. The length opt_len is updated; static_len is
                 also updated if stree is not null. The field max_code is set.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.gen_codes(System.Int16[],System.Int32,System.Int16[])">
            <summary>
             Generate the codes for a given tree and bit counts (which need not be
             optimal).
             IN assertion: the array bl_count contains the bit length statistics for
             the given tree and the field count is set for all tree elements.
             OUT assertion: the field code is set for all tree elements of non
                 zero code length.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.bi_reverse(System.Int32,System.Int32)">
            <summary>
             Reverse the first count bits of a code, using straightforward code (a faster
             method would use a table)
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.DynTree">
            <summary>
            The dynamic tree
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.MaxCode">
            <summary>
            Largest code with non zero frequency
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.StatDesc">
            <summary>
            the corresponding static tree
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZInputStream">
             <summary>
             <para>The <c>ZInputStream</c> class is used for decompression of data. For decompression the inflate algorithm is used.</para>
             <para>To compress data you can use either the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/> class or the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZLibStream"/> class.</para>
             </summary>
             <example> The following code demonstrates how to use the <c>ZInputStream</c> to decompresses data
             <code>
             [C#]
             private void decompressFile(string inFile, string outFile)
            	{
            	  /* Create a file to store decompressed data */
            		System.IO.FileStream decompressedFile = new System.IO.FileStream(@"c:\data\decompressed.dat", System.IO.FileMode.Create);
            		/* Open a file containing compressed data */
            		System.IO.FileStream compressedFile = new System.IO.FileStream(@"c:\data\compressed.dat", System.IO.FileMode.Open);	
            		/* Create ZInputStream for decompression */
            		ZInputStream decompressionStream = new ZInputStream(compressedFile);
            
            		try
            		{
            				byte[] buffer = new byte[2000];
            				int len;
            				/* Read and decompress data */
            				while ((len = decompressionStream.Read(buffer, 0, 2000)) &gt; 0)
            				{
            				  /* Store decompressed data */
            					decompressedFile.Write(buffer, 0, len);
            				}
            		}
            		finally
            		{
            			decompressionStream.Close();
            			decompressedFile.Close();
            			compressedFile.Close();
            		}
            	}
             </code>
             </example>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZInputStream.z">
            <summary>
            ZStream object
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZInputStream.flush">
            <summary>
            Flush strategy
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZInputStream.buf">
            <summary>
            Buffers
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZInputStream.buf1">
            <summary>
            Buffers
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZInputStream._stream">
            <summary>
            Stream to decompress data from
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZInputStream.nomoreinput">
            <summary>
            True if no more input is available
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.InitBlock">
            <summary>
            Initializes a block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor which takes one argument - the <paramref name="stream"/> containing data to decompress.
            </summary>
            <param name="stream">A stream to decompress data from.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.ReadByte">
            <summary>
            Reads a byte of decompressed data from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream. 
            </summary>
            <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream. </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Reads a number of decompressed bytes into the specified byte array. 
             </summary>
             <param name="buffer">The array used to store decompressed bytes.</param>
             <param name="offset">The location in the array to begin reading.</param>
             <param name="count">The number of decompressed bytes to read.</param>
             <returns>The number of bytes that were decompressed into the byte array.</returns>
             <example> The following code demonstrates how to use the <c>ZInputStream</c> to decompresses data
             <code>
             [C#]
             private void decompressFile(string inFile, string outFile)
            	{
            	  /* Create a file to store decompressed data */
            		System.IO.FileStream decompressedFile = new System.IO.FileStream(@"c:\data\decompressed.dat", System.IO.FileMode.Create);
            		/* Open a file containing compressed data */
            		System.IO.FileStream compressedFile = new System.IO.FileStream(@"c:\data\compressed.dat", System.IO.FileMode.Open);	
            		/* Create ZInputStream for decompression */
            		ZInputStream decompressionStream = new ZInputStream(compressedFile);
            
            		try
            		{
            				byte[] buffer = new byte[2000];
            				int len;
            				/* Read and decompress data */
            				while ((len = decompressionStream.Read(buffer, 0, 2000)) > 0)
            				{
            				  /* Store decompressed data */
            					decompressedFile.Write(buffer, 0, len);
            				}
            		}
            		finally
            		{
            			decompressionStream.Close();
            			decompressedFile.Close();
            			compressedFile.Close();
            		}
            	}
             </code>
             </example>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a byte to the stream. Please note, that this method throws the <see cref="T:System.NotSupportedException"/> since <see cref="T:ComponentAce.Compression.Libs.ZLib.ZInputStream"/> doesn't support writing.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Skip(System.Int64)">
            <summary>
            Skips n decompressed bytes in the stream.
            </summary>
            <param name="n">The number of bytes to skip.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Finish(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the final block of decompressed data and finishes decompression.
            </summary>
            <param name="buffer">The array used to store decompressed bytes.</param>
            <param name="offset">The location in the array to begin reading.</param>
            <param name="count">The number of decompressed bytes to read.</param>
            <returns>The number of bytes that were decompressed into the byte array.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.End">
            <summary>
            Frees allocated resources.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Close">
            <summary>
            Closes the stream and the underlying stream.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Flush">
            <summary>
            Flushes the stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream. Please note that the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZInputStream"/> class doesn't support the <see cref="M:System.IO.Stream.SetLength(System.Int64)">SetLength</see> operation and thus the <see cref="T:System.NotSupportedException"/> is thrown.
            </summary>
            <param name="value">A new length of the stream.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek to the offset position (from the beginning or from the current position, etc. see the available values of the <paramref name="origin"/> parameter)in the stream. This method throws an exception since ZInpitStream doesn't support <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)">seeking</see> operation
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZInputStream.FlushMode">
            <summary>
            Gets/Sets the current <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZInputStream.Length">
            <summary>
            Gets the length of the stream in bytes. Please note that the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZInputStream"/> class doesn't support the <see cref="P:System.IO.Stream.Length">Length</see> property and thus the <see cref="T:System.NotSupportedException"/> is thrown.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZInputStream.Position">
            <summary>
            Gets/Sets the current position in the stream.  Please note that the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZInputStream"/> class doesn't support the <see cref="P:System.IO.Stream.Position">Position</see> property and thus the <see cref="T:System.NotSupportedException"/> is thrown.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZInputStream.CanRead">
            <summary>
            Gets a value indicating whether the stream supports reading while decompressing a file. 
            </summary>
            <returns>
            Always returns <c>true</c>.
            </returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZInputStream.CanWrite">
            <summary>
            Gets a value indicating whether the stream supports writing. 
            </summary>
            <returns>For the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZInputStream"/> always returns <c>false</c>.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZInputStream.CanSeek">
            <summary>
            Gets a value indicating whether the stream supports seeking.
            </summary>
            <returns>Always returns <c>false</c>.</returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel">
            <summary>
            Some constants for specifying compression levels. Methods which takes a compression level as a parameter expects an integer value from 0 to 9. You can either specify an integer value or use constants for some most widely used compression levels.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_NO_COMPRESSION">
            <summary>
             No compression should be used at all.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_BEST_SPEED">
            <summary>
            Minimal compression, but greatest speed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_BEST_COMPRESSION">
            <summary>
            Maximum compression, but slowest.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_DEFAULT_COMPRESSION">
            <summary>
            Select default compression level (good compression, good speed).
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.CompressionStrategy">
            <summary>
            Compression strategies. The strategy parameter is used to tune the compression algorithm. The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_FILTERED">
            <summary>
            This strategy is designed for filtered data. Data which consists of mostly small values, with random distribution should use Z_FILTERED. With this strategy, less string matching is performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_HUFFMAN_ONLY">
            <summary>
            Z_HUFFMAN_ONLY forces Huffman encoding only (no string match)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_DEFAULT_STRATEGY">
            <summary>
            The default strategy is the most commonly used. With this strategy, string matching and huffman compression are balanced.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">
            <summary>
            Flush strategies
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_NO_FLUSH">
            <summary>
              Do not internalFlush data, but just write data as normal to the output buffer. This is the normal way in which data is written to the output buffer.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_PARTIAL_FLUSH">
            <summary>
            Obsolete. You should use Z_SYNC_FLUSH instead.
            </summary>        
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH">
            <summary>
            All pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH">
            <summary>
            All output is flushed as with Z_SYNC_FLUSH, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using Z_FULL_FLUSH too often can seriously degrade the compression. ZLib_InflateSync will locate points in the compression string where a full has been performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH">
            <summary>
            Notifies the module that the input has now been exhausted. Pending input is processed, pending output is flushed and calls return with Z_STREAM_END if there was enough output space.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibResultCode">
            <summary>
            Results of operations in ZLib library
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK">
            <summary>
             No failure was encountered, the operation completed without problem.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END">
            <summary>
            No failure was encountered, and the input has been exhausted.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT">
            <summary>
            A preset dictionary is required for decompression of the data.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_ERRNO">
            <summary>
            An internal error occurred
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR">
            <summary>
            The stream structure was inconsistent
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR">
            <summary>
            Input data has been corrupted (for decompression).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR">
            <summary>
            Memory allocation failed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR">
            <summary>
            There was not enough space in the output buffer.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_VERSION_ERROR">
            <summary>
            The version supplied does not match that supported by the ZLib module.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.DeflateState">
            <summary>
            States of deflate operation
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.BlockType">
            <summary>
            Data block types, i.e. binary or ascii text
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibUtil">
            <summary>
            Helper class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.MAX_WBITS">
            <summary>
            Max Window size
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.PRESET_DICT">
            <summary>
            preset dictionary flag in zlib header
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.zLibBufSize">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Z_DEFLATED">
            <summary>
            Deflate compression method index
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.DIST_CODE_LEN">
            <summary>
            see definition of array dist_code below
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to ReadPos from.</param>
            <param name="target">Contains the array of characters ReadPos from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to ReadPos from the source Stream.</param>
            <returns>The number of characters ReadPos. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to ReadPos from</param>
            <param name="target">Contains the array of characteres ReadPos from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to ReadPos from the source TextReader.</param>
            <returns>The number of characters ReadPos. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ToByteArray(System.String)">
            <summary>
            Converts a string to an array of bytes
            </summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.CopyLargeArrayToSmall.CopyData">
            <summary>
            Copies large array which was passed as srcBuf to the Initialize method into the destination array which were passes as destBuff
            </summary>
            <returns>The number of bytes copied</returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.CompressionDirection">
            <summary>
            Compression directions: compression or decompression. This enumeration is used to specify the direction of compression for the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZLibStream"/>.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionDirection.Compression">
            <summary>
            The <c>CompressionDirection.Compression</c> item means compression of data
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionDirection.Decompression">
            <summary>
            The <c>CompressionDirection.Decompression</c> item means decompression of data
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibStream">
            <summary>
            <para>This class represents the Deflate algorithm, an industry standard algorithm for lossless file compression and decompression. It uses a combination of the LZ77 algorithm and Huffman coding. Data can be produced or consumed, even for an arbitrarily long, sequentially presented input data stream, using only previously bound amount of intermediate storage. The format can be implemented readily in a manner not covered by patents. For more information, see RFC 1951. <see href="http://go.microsoft.com/fwlink/?linkid=45286">DEFLATE Compressed Data Format Specification version 1.3.</see></para>
            <para>The compression functionality in ZLibStream is exposed as a stream. Data is read in on a byte-by-byte basis, so it is not possible to perform multiple passes to determine the best method for compressing entire files or large blocks of data.</para>
            </summary>
            <example> Sample code to compress data
            <code>
            [C#]
            public class Test
            {
               public static void Main()
               {
                    /* Open the file containing source data */
                    FileStream sourceStream = new FileStream(@"c:\data\sourceFile.dat", FileMode.Open);
                    /* Create an output stream to store compressed data */
                    FileStream targetStream = new FileStream(@"c:\data\compressedFile.dat", FileMode.CreateNew);
                    /* Create a ZLibStream for compression of data containing in the sourceStream */
                    ZLibStream compressionStream = new ZLibStream(targetStream, CompressionDirection.Compression, false);
                    /* Create a buffer */
                    byte[] buffer = new byte[2000];
                    int len;
                    /* Read source data */
                    while ((len = sourceStream.Read(buffer, 0, 2000)) &gt; 0)
                    {
                        /* Compress the source data and write compressed data to the targetStream */
                        compressionStream.Write(buffer, 0, len);
                    }
                    /* Close streams */
                    sourceStream.Close();
                    compressionStream.Close();
                }
            }
            </code>
            </example>
            <example> Sample code to decompress data
            <code>
            [C#]
            public class Test
            {
               public static void Main()
               {
                    /* Open the file containing compressed data */
                    FileStream sourceStream = new FileStream(@"c:\data\compressedFile.dat", FileMode.Open);
                    /* Create a ZLibStream for decompression of data containing from the sourceStream */
                    ZLibStream decompressionStream = new ZLibStream(sourceStream, CompressionDirection.Decompression, false);
                    /* Create an output stream to store decompressed data */
                    FileStream targetStream = new FileStream(@"c:\data\decompressedFile.dat", FileMode.CreateNew);
                    /* Create a buffer */
                    byte[] buffer = new byte[2000];
                    int len;
                    /* Read data from the decompression stream */
                    while ((len = decompressionStream.Read(buffer, 0, 2000)) &gt; 0)
                    {
                        /* Write decompressed data to the output stream */
                        targetStream.Write(buffer, 0, len);
                    }
                    /* Close streams */
                    targetStream.Close();
                    decompressionStream.Close();
                }
            }
            </code>
            </example>
            <seealso cref="T:ComponentAce.Compression.Libs.ZLib.ZInputStream"/>
            <seealso cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibStream.compressionDirection">
            <summary>
            Whether the stream is used for compression or it is used for decompression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibStream._stream">
            <summary>
            A stream which will be compressed or decompressed
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibStream.decompressionStream">
            <summary>
            Stream that will be used for decompression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibStream.compressionStream">
            <summary>
            Stream that will be used for compression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibStream.compLevel">
            <summary>
            Compression level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibStream.leaveOpen">
            <summary>
            True if we need to leave the underlying stream open when closing the current stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.Flush">
            <summary>
            If the current stream was created as a compression stream (<see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)"/>) this method calls the <see cref="M:System.IO.Stream.Flush"/> method for the underlying stream. If the current stream is a decompression stream this method does nothing.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>The <c>Read</c> method allows you to read data from the <c>ZLibStream</c>. The method is supported for a decompression stream only (<see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)"/>).</para>
            <para>If the current stream is a decompression stream this method reads a block of data from the underlying stream (the one passed to the <see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)"/> constructor), decompresses it using the inflate algorithm and returns decompressed data block.</para>
            </summary>
            <remarks>
            <para>When calling for a compression stream this method throws the <cref see="NotSupportedException"/> exception.</para>
            <para>Use the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.CanRead"/> property to determine whether the current instance supports reading.</para>
            </remarks>
            <param name="buffer">An array of byte in which we want to decompress data. When this method returns the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the decompressed data bytes.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the decompressed data.</param>
            <param name="count">The maximum number of bytes to read from the current stream.</param>
            <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
            <example>This example shows how to decompress data with the ZLibStream.Read method:
            <code>
            public class Test
            {
               public static void Main()
               {
                    /* Open the file containing compressed data */
                    FileStream sourceStream = new FileStream(@"c:\data\compressedFile.dat", FileMode.Open);
                    /* Create a ZLibStream for decompression of data containing in the sourceStream */
                    ZLibStream decompressionStream = new ZLibStream(sourceStream, CompressionDirection.Decompression, false);
                    /* Create an output stream to store decompressed data */
                    FileStream targetStream = new FileStream(@"c:\data\decompressedFile.dat", FileMode.CreateNew);
                    /* Create a buffer */
                    byte[] buffer = new byte[2000];
                    int len;
                    /* Read data from the decompression stream */
                    while ((len = decompressionStream.Read(buffer, 0, 2000)) &gt; 0)
                    {
                        /* Write decompressed data to the output stream */
                        targetStream.Write(buffer, 0, len);
                    }
                    /* Close streams */
                    targetStream.Close();
                    decompressionStream.Close();
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            ZLibStream doesn't support the <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)">seeking</see> and thus the <see cref="T:System.NotSupportedException"/> is always thrown.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.SetLength(System.Int64)">
            <summary>
            ZLibStream doesn't support the <see cref="M:System.IO.Stream.SetLength(System.Int64)">SetLength</see> property and thus the <see cref="T:System.NotSupportedException"/> is always thrown.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>The <c>Write</c> method allows you to write data to the <c>ZLibStream</c>. The method is supported for a compression stream only (<see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)"/>).</para>
            <para>If the current stream is a compression stream this method reads a block of data from the <paramref name="buffer"/>, compresses it and writes to the underlying stream (the one passed to the <see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)"/> constructor).</para>
            </summary>
            <remarks>
            <para>When calling for a decompression stream this method throws the <cref see="NotSupportedException"/> exception.</para>
            <para>Use the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.CanWrite"/> property to determine whether the current instance supports writing.</para>
            </remarks>
            <param name="buffer">An array of byte containing source data. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <example language="C#">This example shows how to compress data with the ZLibStream.Write method:
            <code>
            public class Test
            {
               public static void Main()
               {
                    /* Open the file containing source data */
                    FileStream sourceStream = new FileStream(@"c:\data\sourceFile.dat", FileMode.Open);
                    /* Create an output stream to store compressed data */
                    FileStream targetStream = new FileStream(@"c:\data\compressedFile.dat", FileMode.CreateNew);
                    /* Create a ZLibStream for compression of data containing in the sourceStream */
                    ZLibStream compressionStream = new ZLibStream(targetStream, CompressionDirection.Compression, false);
                    /* Create a buffer */
                    byte[] buffer = new byte[2000];
                    int len;
                    /* Read source data */
                    while ((len = sourceStream.Read(buffer, 0, 2000)) &gt; 0)
                    {
                        /* Compress the source data and write compressed data to the targetStream */
                        compressionStream.Write(buffer, 0, len);
                    }
                    /* Close streams */
                    sourceStream.Close();
                    compressionStream.Close();
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.Close">
            <summary>
            Closes the current stream and the underlying stream depending on the <see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)">leaveOpen</see> parameter passed to the ZLibStream constructor.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)">
            <summary>
            Constructor which creates a new <see cref="T:ComponentAce.Compression.Libs.ZLib.ZLibStream"/> object and initializes it as a compression or a decompression one depending on the <paramref name="dir"/> parameter.
            </summary>
            <param name="stream">The stream containing compressed data for decompression or the stream to store compressed data for compression.</param>
            <param name="dir">One of the <see cref="T:ComponentAce.Compression.Libs.ZLib.CompressionDirection"/> values that indicates the action to take (compression or decompression).</param>
            <param name="leaveOpen">Whether we need to leave the underlying stream open when <see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.Close">closing</see> the current stream.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.GetCompressionDirection">
            <summary>
            Returns the current <see cref="T:ComponentAce.Compression.Libs.ZLib.CompressionDirection">compression direction</see>.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.SetCompressionLevel(System.Int32)">
            <summary>
            Sets compression level for compression stream. If the current stream was created as a decompression stream the <see cref="T:System.NotSupportedException"/> is thrown.
            </summary>
            <param name="level">An integer value indicating the compression level. The parameter can take values from 0 to 9. You can pass -1 as a parameter to use the default compression level.</param>
            <exception cref="T:System.ArgumentException">The <c>ArgumentException</c> exception is thrown if the specified compression level is less then -1 or greater than 9.</exception>
            <exception cref="T:System.NotSupportedException">The NotSupportedException exception is thrown if we call this method for the decompression stream.</exception>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.CanRead">
            <summary>
            CanRead returns <c>false</c> if the current stream is a compression stream. If the current stream is a decompression stream then the property returns the value of the <see cref="P:System.IO.Stream.CanRead"/> property of the underlying stream
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.CanSeek">
            <summary>
            <see cref="T:ComponentAce.Compression.Libs.ZLib.ZLibStream"/> doesn't support the <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)"/> operation and thus this property always returns <c>false</c>
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.CanWrite">
            <summary>
            The property returns <c>false</c> if the current stream is a decompression stream and the value of the <see cref="P:System.IO.Stream.CanWrite"/> property of the underlying stream in case of the stream is a compression stream
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.Length">
            <summary>
            ZLibStream doesn't support the <see cref="P:System.IO.Stream.Length">Length</see> property and thus the <see cref="T:System.NotSupportedException"/> is always thrown.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.Position">
            <summary>
            ZLibStream doesn't allow you to get or set the position in the stream and thus the <see cref="T:System.NotSupportedException"/> is always thrown
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZLibStream.BaseStream">
            <summary>
            Gets the base stream for the current ZLibStream. The base stream is a stream passed to the <see cref="M:ComponentAce.Compression.Libs.ZLib.ZLibStream.#ctor(System.IO.Stream,ComponentAce.Compression.Libs.ZLib.CompressionDirection,System.Boolean)">ZLibStream constructor</see>.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream">
             <summary>
             This class uses the Deflate algorithm (an industry standard algorithm for lossless file compression and decompression) to compress data. When <see cref="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.#ctor(System.IO.Stream,System.Int32)">creating</see> an instance of the class you passes a stream and an integer value indicating the compression level you want to use. The stream passed to the <see cref="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.#ctor(System.IO.Stream,System.Int32)">constructor</see> is used to store compressed data.
             </summary>    
             <example> The following code demonstrates how to use the <c>ZOutputStream</c> to compress data
             <code language="C#">
             [C#]
             private void compressFile(string inFile, string outFile)
            	{
            	    /* Create a file to store compressed data */
            		System.IO.FileStream compressedFile = new System.IO.FileStream(@"c:\data\compressed.dat", System.IO.FileMode.Create);
            		/* Open a file containing source data */
            		System.IO.FileStream sourceFile = new System.IO.FileStream(@"c:\data\source.dat", System.IO.FileMode.Open);	
            		/* Create ZOutputStream for compression */
            		ZOutputStream compressionStream = new ZOutputStream(compressedFile);
            
            		try
            		{
            				byte[] buffer = new byte[2000];
            				int len;
            				/* Read and compress data */
            				while ((len = sourceFile.Read(buffer, 0, 2000)) &gt; 0)
            				{
            				  /* Store compressed data */
            					compressionStream.Write(buffer, 0, len);
            				}
            		}
            		finally
            		{
            			compressionStream.Close();
            			sourceFile.Close();
            			compressedFile.Close();
            		}
            	}
             </code>
             </example>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZOutputStream.z">
            <summary>
            A ZStream object
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZOutputStream.flush">
            <summary>
            Current internalFlush strategy
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZOutputStream.buf">
            <summary>
            Buffer byte arrays
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZOutputStream.buf1">
            <summary>
            Buffer byte arrays
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZOutputStream._stream">
            <summary>
            Out stream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Constructor which takes two parameters: the <paramref name="stream"/> to store compressed data in and the desired compression level.
            </summary>
            <param name="stream">A stream to be used to store compressed data.</param>
            <param name="level">An integer value indicating the desired compression level. The compression level can take values from 0 to 9. The maximum value indicates that the maximum compression should be achieved (but this method will be the slowest one). 0 means that no compression should be used at all. If you want to use the default compression level you can pass -1. Also you can use the constants from the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel"/> class.</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Writes a byte array to the stream. This block of data is compressed and stored in the stream passed as a parameter to the <see cref="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.#ctor(System.IO.Stream,System.Int32)">class constructor</see>.
             </summary>
             <param name="buffer">A byte array to compress.</param>
             <param name="offset">Offset of the first byte to compress.</param>
             <param name="count">The number of bytes to compress from the buffer.</param>
             <example> The following code demonstrates how to use the <c>ZOutputStream</c> to compress data
             <code>
             [C#]
             private void compressFile(string inFile, string outFile)
            	{
            	    /* Create a file to store compressed data */
            		System.IO.FileStream compressedFile = new System.IO.FileStream(@"c:\data\compressed.dat", System.IO.FileMode.Create);
            		/* Open a file containing source data */
            		System.IO.FileStream sourceFile = new System.IO.FileStream(@"c:\data\source.dat", System.IO.FileMode.Open);	
            		/* Create ZOutputStream for compression */
            		ZOutputStream compressionStream = new ZOutputStream(compressedFile);
            
            		try
            		{
            				byte[] buffer = new byte[2000];
            				int len;
            				/* Read and compress data */
            				while ((len = sourceFile.Read(buffer, 0, 2000)) &gt; 0)
            				{
            				  /* Store compressed data */
            					compressionStream.Write(buffer, 0, len);
            				}
            		}
            		finally
            		{
            			compressionStream.Close();
            			sourceFile.Close();
            			compressedFile.Close();
            		}
            	}
             </code>
             </example>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Finish">
            <summary>
            Finishes compression.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.End">
            <summary>
            Frees allocated resources.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Close">
            <summary>
            Close the current and the underying streams.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read data from the stream. Please note, that this method throws the <see cref="T:System.NotSupportedException"/> exception since <see cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/> doesn't support <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)">reading</see>.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream. This method throws the <see cref="T:System.NotSupportedException"/> exception since the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/> class doesn't support <see cref="M:System.IO.Stream.SetLength(System.Int64)">the operation</see>.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position in the stream. This method throws the <see cref="T:System.NotSupportedException"/> exception since the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/> class doesn't support <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)">the operation</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZOutputStream.FlushMode">
            <summary>
            Gets/Sets the <see creg="FlushStrategy">flush</see> strategy to use during compression.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZOutputStream.CanRead">
            <summary>
            Gets a value indicating whether the stream supports reading.
            </summary>
            <remarks>Always returns <c>false</c> since the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/> doesn't support reading.</remarks>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZOutputStream.CanSeek">
            <summary>
            Whether we can seek to a position in the stream.
            </summary>
            <returns>Always returns false since the <see cref="T:ComponentAce.Compression.Libs.ZLib.ZOutputStream"/> doesn't support <see creg="Stream.Seek">seeking</see>.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZOutputStream.CanWrite">
            <summary>
            Whether the stream supports the writing operation.
            </summary>
            <returns>This property always returns <c>true</c>.</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Length">
            <summary>
            Returns the length of the stream. Please note that this property always throws the <see cref="T:System.NotSupportedException"/> exception since the stream doesn't support the <see cref="P:System.IO.Stream.Length">property</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZOutputStream.Position">
            <summary>
            Returns the current position in the compressed stream. This property throws the <see cref="T:System.NotSupportedException"/> exception since the stream doesn't support <see cref="P:System.IO.Stream.Position">this property</see>.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZStream">
            <summary>
            ZStream is used to store user data to compress/decompress.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream.MAX_MEM_LEVEL">
            <summary>
            Maximum memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_in">
            <summary>
            Next input byte array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_in_index">
            <summary>
            Index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input array</see>.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._avail_in">
            <summary>
            Number of bytes available at _next_in
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._total_in">
            <summary>
            total nb of input bytes ReadPos so far
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_out">
            <summary>
            Byte array for the next output block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_out_index">
            <summary>
            Index of the first byte in the _next_out array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._avail_out">
            <summary>
            Remaining free space at _next_out
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._total_out">
            <summary>
            Total number of bytes in output array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._msg">
            <summary>
            A string to store operation result message (corresponding to result codes)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._dstate">
            <summary>
            A deflate object to perform data compression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._istate">
            <summary>
            Inflate object to perform data decompression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream.data_type">
            <summary>
            Best guess about the data type: ascii or binary
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._adler">
            <summary>
            A checksum computed with Adler algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit">
            <summary>
            Initializes the internal stream state for decompression. The fields <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/>, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> must be initialized before by the caller. If <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> is not <c>null</c> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> is large enough (the exact value depends on the compression method), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit"/> determines the compression method from the ZLib header and allocates all data structures accordingly; otherwise the allocation will be deferred to the first call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. 
            </summary>
            <returns>
            inflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory,  <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_VERSION_ERROR"/> if the ZLib library version is incompatible with the version assumed by the caller. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to <c>null</c> if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit"/> does not perform any decompression apart from reading the ZLib header if present: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. (So <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> may be modified, but <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> are unchanged.)
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)">
            <summary>
            This is another version of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit"/> with an extra parameter. The fields <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/>, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> must be initialized before by the caller. If <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> is not <c>null</c> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> is large enough (the exact value depends on the compression method), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)"/> determines the compression method from the ZLib header and allocates all data structures accordingly; otherwise the allocation will be deferred to the first call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. 
            </summary>
            <param name="windowBits">The <c>windowBits</c> parameter is the base two logarithm of the maximum window size (the size of the history buffer). It should be in the range <c>8..15</c> for this version of the library. The default value is 15 if <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)"/> is used instead. If a compressed stream with a larger window size is given as input, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> will return with the error code <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> instead of trying to allocate a larger window.</param>
            <returns>
            inflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if a parameter is invalid (such as a negative memLevel). <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to null if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)"/> does not perform any decompression apart from reading the ZLib header if present: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. (So <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> may be modified, but <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> are unchanged.)
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            <para>This method decompresses as much data as possible, and stops when the input buffer (<see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/>) becomes empty or the output buffer (<see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/>) becomes full. It may some introduce some output latency (reading input without producing any output) except when forced to flush. </para>
            <para>The detailed semantics are as follows. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> performs one or both of the following actions: </para>
            <para>
            <list type="bullet">
            <item>Decompress more input starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> accordingly. If not all input can be processed (because there is not enough room in the output buffer), <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> is updated and processing will resume at this point for the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. </item>
            <item>Provide more output starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> accordingly. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> provides as much output as possible, until there is no more input data or no more space in the output buffer (see below about the <paramref name="flush"/> parameter).</item>
            </list>
            </para>
            </summary>
            <param name="flush"><see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">Flush strategy</see> to use.</param>
            <remarks>
            <para>Before the call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>, the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating the next_* and avail_* values accordingly. The application can consume the uncompressed output when it wants, for example when the output buffer is full (<c>avail_out == 0</c>), or after each call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. If <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> and with zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>, it must be called again after making room in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> because there might be more output pending. </para>
            <para>If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/>, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> flushes as much output as possible to the output buffer. The flushing behavior of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> is not specified for values of the <paramref name="flush"/> parameter other than <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/> and <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>, but the current implementation actually flushes as much output as possible anyway. </para>
            <para><see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> should normally be called until it returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> or an error. However if all decompression is to be performed in a single step (a single call of inflate), the parameter <paramref name="flush"/> should be set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>. In this case all pending input is processed and all pending output is flushed ; <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> must be large enough to hold all the uncompressed data. (The size of the uncompressed data may have been saved by the compressor for this purpose.) The next operation on this stream must be <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateEnd"/> to deallocate the decompression state. The use of <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> is never required, but can be used to inform <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> that a faster routine may be used for the single <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> call. </para>
            <para>If a preset dictionary is needed at this point (see <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)"/>), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> sets strm-adler to the adler32 checksum of the dictionary chosen by the compressor and returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT"/> ; otherwise it sets strm-&gt;adler to the adler32 checksum of all output produced so far (that is, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_out"/> bytes) and returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/>, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> or an error code as described below. At the end of the stream, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>) checks that its computed adler32 checksum is equal to that saved by the compressor and returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> only if the checksum is correct.</para>
            </remarks>
            <returns>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if some progress has been made (more input processed or more output produced), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> if the end of the compressed data has been reached and all uncompressed output has been produced, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT"/> if a preset dictionary is needed at this point, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if the input data was corrupted (input stream not conforming to the ZLib format or incorrect adler32 checksum), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream structure was inconsistent (for example if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> was <c>null</c>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if no progress is possible or if there was not enough room in the output buffer when <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> is used. In the <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> case, the application may then call <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync"/> to look for a good compression block.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateEnd">
            <summary>
            All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending output.
            </summary>
            <returns>
            inflateEnd returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream state was inconsistent. In the error case, msg may be set but then points to a static string (which must not be deallocated).
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync">
            <summary>
            Skips invalid compressed data until a full flush point (see the description of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">deflate with Z_FULL_FLUSH</see>) can be found, or until all available input is skipped. No output is provided.
            </summary>
            <returns>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync"/> returns <seec ref="ZLibResultCode.Z_OK"/> if a full flush point has been found, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if no more input was provided, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if no flush point has been found, or <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream structure was inconsistent. In the success case, the application may save the current current value of <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in"/> which indicates where valid compressed data was found. In the error case, the application may repeatedly call <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync"/>, providing more input each time, until success or end of the input data.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)">
            <summary>
            Initializes the decompression dictionary from the given uncompressed byte sequence. This function must be called immediately after a call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> if this call returned <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT"/>. The dictionary chosen by the compressor can be determined from the Adler32 value returned by this call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. The compressor and decompresser must use exactly the same dictionary.
            </summary>
            <param name="dictionary">A byte array - a dictionary.</param>
            <param name="dictLength">The length of the dictionary.</param>
            <returns>
            inflateSetDictionary returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if a parameter is invalid (such as <c>null</c> dictionary) or the stream state is inconsistent, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if the given dictionary doesn't match the expected one (incorrect Adler32 value). inflateSetDictionary does not perform any decompression: this will be done by subsequent calls of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)">
            <summary>
            Initializes the internal stream state for compression. 
            </summary>
            <param name="level">An integer value from 0 to 9 indicating the desired compression level.</param>
            <returns>
            deflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if level is not a valid compression level. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to <c>null</c> if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32,System.Int32)">
            <summary>
            Initializes the internal stream state for compression. 
            </summary>
            <param name="level">An integer value from 0 to 9 indicating the desired compression level.</param>
            <param name="bits"> The windowBits parameter is the base two logarithm of the window size (the size of the history buffer). It should be in the range 8..15 for this version of the library. Larger values of this parameter result in better compression at the expense of memory usage. The default value is 15 if deflateInit is used instead.</param>
            <returns>
            deflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR"/> if there was not enough memory, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if level is not a valid compression level. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> is set to <c>null</c> if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32,System.Int32)"/> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            <para>Deflate compresses as much data as possible, and stops when the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see> becomes empty or the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.</para>
            <para>The detailed semantics are as follows. deflate performs one or both of the following actions:
            <list type="bullet">
            <item>Compress more input starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> accordingly. If not all input can be processed (because there is not enough room in the output buffer), <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> are updated and processing will resume at this point for the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. </item>
            <item>Provide more output starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> accordingly. This action is forced if the parameter flush is non zero. Forcing flush frequently degrades the compression ratio, so this parameter should be set only when necessary (in interactive applications). Some output may be provided even if flush is not set.</item>
            </list>
            </para>
            </summary>
            <param name="flush">The <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see> to use.</param>
            <remarks>
            <para>Before the call of <seec ref="deflate"/>, the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> accordingly ; <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full (<c>avail_out == 0</c>), or after each call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. If <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> and with zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>, it must be called again after making room in the output buffer because there might be more output pending. </para>
            <para>If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/>, all pending output is flushed to the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. (In particular <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> is zero after the call if enough output space has been provided before the call.) Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. </para>
            <para>If flush is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH"/>, all output is flushed as with <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH"/>, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH"/> too often can seriously degrade the compression.</para>
            </remarks>
            <returns>
            <para>If deflate returns with <c><see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> == 0</c>, this function must be called again with the same value of the flush parameter and more output space (updated <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>), until the flush is complete (<see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns with non-zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>). </para>
            <para>If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>, pending input is processed, pending output is flushed and deflate returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> if there was enough output space ; if deflate returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/>, this function must be called again with <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> and more output space (updated <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/>) but no more input data, until it returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> or an error. After deflate has returned <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/>, the only possible operation on the stream is<see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateEnd"/>. </para>
            <para><see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/> can be used immediately after <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/> if all the compression is to be done in a single step. In this case, avail_out must be at least 0.1% larger than avail_in plus 12 bytes. If deflate does not return Z_STREAM_END, then it must be called again as described above. </para>
            <para><see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> sets strm-&gt; adler to the adler32 checksum of all input read so far (that is, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in"/> bytes). </para>
            <para><see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> may update data_type if it can make a good guess about the input data type (<see cref="T:ComponentAce.Compression.Libs.ZLib.BlockType">Z_ASCII or Z_BINARY</see>). In doubt, the data is considered binary. This field is only for information purposes and does not affect the compression algorithm in any manner. </para>
            <para><see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if some progress has been made (more input processed or more output produced), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END"/> if all input has been consumed and all output has been produced (only when flush is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH"/>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream state was inconsistent (for example if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> was <c>null</c>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if no progress is possible (for example <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in"/> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> was zero).</para>
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateEnd">
            <summary>
            All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending output.
            </summary>
            <returns>
            deflateEnd returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the stream state was inconsistent, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR"/> if the stream was freed prematurely (some input or output was discarded). In the error case, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg"/> may be set but then points to a static string (which must not be deallocated).
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateParams(System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Dynamically update the compression level and compression strategy. The interpretation of level is as in <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/>. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and may be flushed); the new level will take effect only at the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>
            </summary>
            <param name="level">An integer value indicating the desired compression level.</param>
            <param name="strategy">A <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see> to use.</param>
            <remarks>
            Before the call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateParams(System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)"/>, the stream state must be set as for a call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>, since the currently available input may have to be compressed and flushed. In particular, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> must be non-zero.
            </remarks>
            <returns>
            deflateParams returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if the source stream state was inconsistent or if a parameter was invalid, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR"/> if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out"/> was zero.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateSetDictionary(System.Byte[],System.Int32)">
            <summary>
            Initializes the compression dictionary from the given byte sequence without producing any compressed output. This function must be called immediately after <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/>, before any call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. The compressor and decompressor must use exactly the same dictionary (see <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)"/>).
            </summary>
            <param name="dictionary">A byte array - a dictionary.</param>
            <param name="dictLength">The length of the dictionary byte array</param>
            <remarks>
            <para>The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, with the most commonly used strings preferably put towards the end of the dictionary. Using a dictionary is most useful when the data to be compressed is short and can be predicted with good accuracy; the data can then be compressed better than with the default empty dictionary.</para>
            <para>Depending on the size of the compression data structures selected by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateInit(System.Int32)"/>, a part of the dictionary may in effect be discarded, for example if the dictionary is larger than the window size in <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>. Thus the strings most likely to be useful should be put at the end of the dictionary, not at the front.</para>
            <para>Upon return of this function, adler is set to the Adler32 value of the dictionary; the decompresser may later use this value to determine which dictionary has been used by the compressor. (The Adler32 value applies to the whole dictionary even if only a subset of the dictionary is actually used by the compressor.)</para>
            </remarks>
            <returns>
            deflateSetDictionary returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK"/> if success, or <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR"/> if a parameter is invalid (such as <c>null</c> dictionary) or the stream state is inconsistent (for example if <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> has already been called for this stream or if the compression method is bsort). <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateSetDictionary(System.Byte[],System.Int32)"/> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/>.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.flush_pending">
            <summary>
            Flush as much pending output as possible. All <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> output goes through this function so some applications may wish to modify it to avoid allocating a large <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> buffer and copying into it.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.read_buf(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.read_buf(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a new buffer from the current input stream, update the adler32 and total number of bytes read.  All <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)"/> input goes through this function so some applications may wish to modify it to avoid allocating a large <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in"/> buffer and copying from it.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.flush_pending"/>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.free">
            <summary>
            Frees all inner <see cref="T:ComponentAce.Compression.Libs.ZLib.ZStream"/> buffers.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.adler">
            <summary>
            Adler-32 value for uncompressed data processed so far.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.Data_type">
            <summary>
            Best guess about the data type: ascii or binary
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">
            <summary>
            Gets/Sets the next input byte array.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in_index">
            <summary>
            Index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input array</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in">
            <summary>
            Gets/Sets the number of bytes available in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in">
            <summary>
            Gets/Sets the total number of bytes in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">
            <summary>
            Gets/Sets the buffer for the next output data.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out_index">
            <summary>
            Gets/Sets the index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> byte array to write to.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out">
            <summary>
            Gets/Sets the remaining free space in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out"/> buffer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_out">
            <summary>
            Gets/Sets the total number of bytes in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output array</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg">
            <summary>
            Gets sets the last error message occurred during class operations.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.dstate">
            <summary>
            A deflate object to perform data compression
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.istate">
            <summary>
            Inflate object to perform data decompression
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZStreamException">
            <summary>
            Exceptions that occur in ZStream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStreamException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStreamException.#ctor(System.String)">
            <summary>
            Constructor which takes one parameter - an error message
            </summary>
        </member>
    </members>
</doc>
